#+TITLE: DotEmacs
#+AUTHOR: Mathieu Marques
#+PROPERTY: header-args :results silent

* Bootstrap

** Better Defaults

Here are what I consider better defaults as per my own experience.

#+BEGIN_SRC emacs-lisp
(setq-default
 ad-redefinition-action 'accept         ; Silence warnings for redefinition
 auto-save-list-file-prefix nil         ; Prevent tracking for auto-saves
 cursor-in-non-selected-windows nil     ; Hide the cursor in inactive windows
 cursor-type '(hbar . 2)                ; Underline-shaped cursor
 custom-unlispify-menu-entries nil      ; Prefer kebab-case for titles
 custom-unlispify-tag-names nil         ; Prefer kebab-case for symbols
 delete-by-moving-to-trash t            ; Delete files to trash
 fill-column 80                         ; Set width for automatic line breaks
 gc-cons-threshold (* 8 1024 1024)      ; We're not using Game Boys anymore
 help-window-select t                   ; Focus new help windows when opened
 indent-tabs-mode nil                   ; Stop using tabs to indent
 inhibit-startup-screen t               ; Disable start-up screen
 initial-scratch-message ""             ; Empty the initial *scratch* buffer
 mouse-yank-at-point t                  ; Yank at point rather than pointer
 native-comp-async-report-warnings-errors 'silent ; Skip error buffers
 read-process-output-max (* 1024 1024)  ; Increase read size for data chunks
 recenter-positions '(5 bottom)         ; Set re-centering positions
 scroll-conservatively 101              ; Avoid recentering when scrolling far
 scroll-margin 2                        ; Add a margin when scrolling vertically
 select-enable-clipboard t              ; Merge system's and Emacs' clipboard
 sentence-end-double-space nil          ; Use a single space after dots
 show-help-function nil                 ; Disable help text everywhere
 tab-always-indent 'complete            ; Indent first then try completions
 tab-width 4                            ; Smaller width for tab characters
 uniquify-buffer-name-style 'forward    ; Uniquify buffer names
 use-short-answers t                    ; Replace yes/no prompts with y/n
 window-combination-resize t            ; Resize windows proportionally
 x-stretch-cursor t)                    ; Stretch cursor to the glyph width
(blink-cursor-mode 0)                   ; Prefer a still cursor
(delete-selection-mode 1)               ; Replace region when inserting text
(global-subword-mode 1)                 ; Iterate through CamelCase words
(mouse-avoidance-mode 'exile)           ; Avoid collision of mouse with point
(put 'downcase-region 'disabled nil)    ; Enable `downcase-region'
(put 'upcase-region 'disabled nil)      ; Enable `upcase-region'
(set-default-coding-systems 'utf-8)     ; Default to utf-8 encoding
#+END_SRC

Change a few indenting behaviors.

#+BEGIN_SRC emacs-lisp
(put 'add-function 'lisp-indent-function 2)
(put 'advice-add 'lisp-indent-function 2)
(put 'plist-put 'lisp-indent-function 2)
#+END_SRC

Allow a number of commonly used and safe file variables.

#+BEGIN_SRC emacs-lisp
(put 'after-save-hook 'safe-local-variable
     (lambda (value) (equal value '(org-babel-tangle t))))
(put 'display-line-numbers-width 'safe-local-variable 'integerp)
#+END_SRC

Unbind the =suspend-frame= command.

#+BEGIN_SRC emacs-lisp
(global-unset-key (kbd "C-x C-z"))
#+END_SRC

** Fullscreen

Enable fullscreen. Given there are differences in meaning for /fullscreen/
between window managers, the following tree aims to provide a pain-free
experience with regard to fullscreen in most setups.

In the case of macOS, fullscreen means Emacs will occupy a dedicated workspace
so we want to maximize it instead. Works best with titlebar-less frames.

Ideally, this should stay near the top of the file so that Emacs appear
fullscreen immediately.

#+BEGIN_SRC emacs-lisp
(pcase window-system
  ('w32 (set-frame-parameter nil 'fullscreen 'fullboth))
  (_ (set-frame-parameter nil 'fullscreen 'maximized)))
#+END_SRC

** Packages

This configuration relies on =straight= and prefers latest Git heads for its
packages over the default behavior from the built-in =package.el= which pulls
releases from (M)ELPA.

For customizing and loading the packages, =use-package= incentivizes clearly
defined, consistent and more efficient configurations for all packages used in
this document.

#+BEGIN_SRC emacs-lisp
(setq-default
 straight-use-package-by-default t)     ; Allow `use-package' interface
#+END_SRC

Bootstrap =straight=.

#+BEGIN_SRC emacs-lisp
(let* ((bootstrap-file "straight/repos/straight.el/bootstrap.el")
       (bootstrap-path (expand-file-name bootstrap-file user-emacs-directory))
       (bootstrap-version 5)
       (install.el "https://raw.githubusercontent.com/raxod502/straight.el/develop/install.el"))
  (unless (file-exists-p bootstrap-path)
    (with-current-buffer
        (url-retrieve-synchronously install.el 'silent 'inhibit-cookies)
      (goto-char (point-max))
      (eval-print-last-sexp)))
  (load bootstrap-path nil 'nomessage))
#+END_SRC

Install =use-package= and defer all packages by default.

#+BEGIN_SRC emacs-lisp
(straight-use-package 'use-package)
(setq-default use-package-always-defer t)
#+END_SRC

** Cache

Use =.cache/= to contain local data. This is to avoid littering in the Emacs
directory with an ever-growing number of packages used on a daily basis.

#+BEGIN_SRC emacs-lisp
(use-package shelldock
  :load-path "lisp/shelldock"
  :straight nil
  :commands (shelldock))
#+END_SRC

Garbage-collect on focus-out, Emacs /should/ feel snappier overall.

#+BEGIN_SRC emacs-lisp
(add-function :after after-focus-change-function
  (defun me/garbage-collect-maybe ()
    (unless (frame-focus-state)
      (garbage-collect))))
#+END_SRC

I chose to lay out my configurations and customizations in this very Org
document for better visibility and maintainability through time and various
upgrades. Albeit useful, the =customize-*= routines go against that strategy by
writing directly at the end of the =user-init-file= or into a dedicated file
when set accordingly.

To fight the littering I've decided to completely disable this feature and
redirect the writing to =/dev/null=.

#+BEGIN_SRC emacs-lisp
(setq-default custom-file null-device)
#+END_SRC

** Load Secrets

Small framework to read secrets out of a machine-local file. Mostly to keep
sensible values out of version control, this is also used to have
machine-specific settings.

#+BEGIN_SRC emacs-lisp
(use-package szadek
  :load-path "lisp/szadek"
  :straight nil
  :commands (szadek-get)
  :custom
  (szadek-file (shelldock "szadek.eld"))
  (szadek-fix-missing t))
#+END_SRC

* Theme

** Morophon

#+BEGIN_SRC emacs-lisp
(use-package morophon
  :load-path "lisp/morophon"
  :straight nil
  :commands (morophon-cycle morophon-disable-themes)
  :custom
  (morophon-known-themes '(zenmelt modus-operandi)))
#+END_SRC

** Customize Fringes

Customize line-continuation indicator bitmaps.

#+BEGIN_SRC emacs-lisp
(define-fringe-bitmap 'left-curly-arrow [16 48 112 240 240 112 48 16])
(define-fringe-bitmap 'right-curly-arrow [8 12 14 15 15 14 12 8])
#+END_SRC

Mute their colors as well.

#+BEGIN_SRC emacs-lisp
(set-fringe-bitmap-face 'left-curly-arrow 'shadow)
(set-fringe-bitmap-face 'right-curly-arrow 'shadow)
#+END_SRC

** Customize Typography

#+BEGIN_SRC emacs-lisp
(defun me/typography-reset ()
  (let ((font-fixed (szadek-get 'font-fixed "monospace"))
        (font-size (szadek-get 'font-size 120))
        (font-variable (szadek-get 'font-variable "monospace")))
    (set-face-attribute 'default nil :font font-fixed :height font-size)
    (set-face-attribute 'fixed-pitch nil :font font-fixed :height font-size)
    (set-face-attribute 'mode-line nil :height font-size :inherit 'default)
    (set-face-attribute 'mode-line-inactive nil :inherit 'mode-line)
    (set-face-attribute 'variable-pitch nil :font font-variable)))
(me/typography-reset)
#+END_SRC

#+BEGIN_SRC emacs-lisp
(add-hook 'szadek-on-save-hook #'me/typography-reset)
#+END_SRC

** Themes

#+BEGIN_SRC emacs-lisp
(use-package modus-themes
  :straight nil
  :custom
  (modus-themes-diffs 'fg-only)
  (modus-themes-mode-line '(accented borderless))
  (modus-themes-no-mixed-fonts t)
  (modus-themes-operandi-color-overrides
   '((bg-main . "#FAFAFA")
     (fg-main . "#101010")
     (fg-window-divider-inner . "#FAFAFA")))
  (modus-themes-org-blocks 'tinted-background))
#+END_SRC

All praise the alien fruit salad theme!
[[https://kippura.org/zenburnpage/][Zenburn]].

I have been using this /easy-on-the-eyes/ pastel theme for a very long time.
After having added one too many customization to it, I went ahead and made my
own fork: Zenmelt.

It doesn't support the many packages that have made it to your own
configurations on purpose, the idea -- albeit selfish -- is to have one place
where I can freely customize colors following my moods without having to
maintain a 2K lines-long file of unnecessary face properties.

In addition to the already popular implementation from
[[https://github.com/bbatsov/zenburn-emacs][Bozhidar Batsov]], this fork also
adds a /reset/ on save when visiting the theme file.

#+BEGIN_SRC emacs-lisp
(use-package zenmelt-theme
  :load-path "lisp/zenmelt"
  :straight nil
  :demand
  :config
  (put 'after-save-hook 'safe-local-variable
       (lambda (value) (equal value '(zenmelt--reset t))))
  (load-theme 'zenmelt t))
#+END_SRC

* Languages

** CSS

#+BEGIN_SRC emacs-lisp
(use-package css-mode
  :straight nil
  :custom
  (css-indent-offset 2))
#+END_SRC

** CSV

#+BEGIN_SRC emacs-lisp
(use-package csv-mode
  :bind
  (:map csv-mode-map
   ("<backtab>" . csv-backward-field)
   ("<tab>" . csv-forward-field))
  :hook
  (csv-mode . csv-align-mode))
#+END_SRC

** HTML

HTML mode is defined in =sgml-mode.el=.

#+BEGIN_SRC emacs-lisp
(use-package sgml-mode
  :straight nil
  :hook
  (html-mode . (lambda () (setq me/pretty-print-function #'sgml-pretty-print)))
  (html-mode . sgml-electric-tag-pair-mode)
  (html-mode . sgml-name-8bit-mode)
  :custom
  (sgml-basic-offset 2))
#+END_SRC

** JavaScript

There might be confusion between the too many JavaScript editing modes
available:

- =js-mode= ::
  Default built-in major mode to edit JavaScript buffers. Supports JSX syntax
  albeit with weak highlighting capabilities.
- =javascript-mode= ::
  An alias to =js-mode=.
- =js2-mode= ::
  An editing major mode with its own parser and extrea features such as
  highlighting for errors and warnings. See [[https://github.com/mooz/js2-mode]].
- =js2-minor-mode= (and =js2-jsx-mode= for Emacs 27) ::
  Two minor modes shipped with =js2-mode= that let you use another major mode
  without discarding the AST parser from =js2-mode=.
- =rjsx-mode= ::
  A major mode to edit JSX buffers based on =js2-mode=. See
  [[https://github.com/felipeochoa/rjsx-mode]].

I went with the route that uses built-ins the most since I am set on using
[[#tree-sitter][Tree-sitter]] to power up the syntax highlighting.

| Syntax | Modes                 |
|--------+-----------------------|
| =.js=  | =js-mode=             |
| =.jsx= | =js-mode=             |
| =.ts=  | =typescript-mode=     |
| =.tsx= | =typescript-tsx-mode= |

#+BEGIN_SRC emacs-lisp
(use-package js-mode
  :straight nil
  :custom
  (js-indent-level 2)
  (js-switch-indent-offset 2))

(use-package typescript-mode
  :init
  (define-derived-mode typescript-tsx-mode typescript-mode "TSX")
  (add-to-list 'auto-mode-alist `(,(rx ".tsx" eos) . typescript-tsx-mode))
  :config
  (add-hook 'typescript-tsx-mode-hook #'sgml-electric-tag-pair-mode)
  :custom
  (typescript-indent-level 2))
#+END_SRC

** JSON

#+BEGIN_SRC emacs-lisp
(use-package json-mode
  :mode (rx ".json" eos))
#+END_SRC

** Lisp

#+BEGIN_SRC emacs-lisp
(use-package emacs-lisp-mode
  :straight nil
  :bind
  (:map emacs-lisp-mode-map
   ("C-c C-c" . me/eval-region-dwim)
   ("C-x C-S-e" . eval-print-last-sexp)
   :map lisp-interaction-mode-map
   ("C-c C-c" . me/eval-region-dwim))
  :custom
  (emacs-lisp-docstring-fill-column nil)
  :hook
  (emacs-lisp-mode . flymake-mode)
  (emacs-lisp-mode . outline-minor-mode))
#+END_SRC

#+BEGIN_SRC emacs-lisp
(defun me/eval-region-dwim ()
  "When region is active, evaluate it and kill the mark. Else, evaluate the
whole buffer."
  (interactive)
  (if (not (region-active-p))
      (eval-buffer)
    (eval-region (region-beginning) (region-end))
    (setq-local deactivate-mark t)))
#+END_SRC

#+BEGIN_SRC emacs-lisp
(use-package ielm
  :straight nil
  :hook
  (ielm-mode . (lambda () (setq-local scroll-margin 0))))
#+END_SRC

#+BEGIN_SRC emacs-lisp
(use-package lisp-mode
  :straight nil
  :mode ((rx ".eld" eos) . lisp-data-mode))
#+END_SRC

** Markdown

#+BEGIN_SRC emacs-lisp
(use-package markdown-mode
  :mode (rx (or "INSTALL" "CONTRIBUTORS" "LICENSE" "README" ".mdx") eos)
  :bind
  (:map markdown-mode-map
   ("M-n" . nil)
   ("M-p" . nil))
  :custom
  (markdown-asymmetric-header t)
  (markdown-split-window-direction 'right)
  :config
  (unbind-key "M-<down>" markdown-mode-map)
  (unbind-key "M-<up>" markdown-mode-map))
#+END_SRC

** Org

This very file is organized with =org-mode=. Like Markdown, but with
superpowers.

| TODO | Check out =org-capture= |

#+BEGIN_QUOTE
Org mode is for keeping notes, maintaining TODO lists, planning projects, and
authoring documents with a fast and effective plain-text system.

--- Carsten Dominik
#+END_QUOTE

#+BEGIN_SRC emacs-lisp
(use-package org
  :straight (:type built-in)
  :bind
  (:map org-mode-map
   ("C-<return>" . nil)
   ("C-<tab>" . me/org-cycle-parent))
  :custom
  (org-adapt-indentation nil)
  (org-babel-python-command "python3")
  (org-confirm-babel-evaluate nil)
  (org-cycle-separator-lines 0)
  (org-descriptive-links nil)
  (org-edit-src-content-indentation 0)
  (org-edit-src-persistent-message nil)
  (org-fontify-done-headline t)
  (org-fontify-quote-and-verse-blocks t)
  (org-fontify-whole-heading-line t)
  (org-return-follows-link t)
  (org-src-preserve-indentation t)
  (org-src-tab-acts-natively t)
  (org-src-window-setup 'current-window)
  (org-startup-truncated nil)
  (org-support-shift-select 'always)
  :config
  (require 'ob-shell)
  (org-babel-do-load-languages
   'org-babel-load-languages '((python . t) (shell . t)))
  (modify-syntax-entry ?' "'" org-mode-syntax-table)
  (advice-add 'org-src--construct-edit-buffer-name :override
    #'me/org-src-buffer-name)
  (with-eval-after-load 'evil
    (evil-define-key* 'motion org-mode-map
      (kbd "<tab>") #'org-cycle
      (kbd "C-j") #'me/org-show-next-heading-tidily
      (kbd "C-k") #'me/org-show-previous-heading-tidily))
  :hook
  (org-mode . buffer-face-mode))
#+END_SRC

#+BEGIN_SRC emacs-lisp
(defun me/org-src-buffer-name (name &rest _)
  "Simple buffer name."
  (format "*%s*" name))

(defun me/org-cycle-parent (argument)
  "Go to the nearest parent heading and execute `org-cycle'."
  (interactive "p")
  (if (org-at-heading-p)
      (outline-up-heading argument)
    (org-previous-visible-heading argument))
  (org-cycle))

(defun me/org-show-next-heading-tidily ()
  "Show next entry, keeping other entries closed."
  (interactive)
  (if (save-excursion (end-of-line) (outline-invisible-p))
      (progn (org-show-entry) (outline-show-children))
    (outline-next-heading)
    (unless (and (bolp) (org-at-heading-p))
      (org-up-heading-safe)
      (outline-hide-subtree)
      (user-error "[Dotemacs] Boundary reached"))
    (org-overview)
    (org-reveal t)
    (org-show-entry)
    (outline-show-children)))

(defun me/org-show-previous-heading-tidily ()
  "Show previous entry, keeping other entries closed."
  (interactive)
  (let ((pos (point)))
    (outline-previous-heading)
    (unless (and (< (point) pos) (bolp) (org-at-heading-p))
      (goto-char pos)
      (outline-hide-subtree)
      (user-error "[Dotemacs] Boundary reached"))
    (org-overview)
    (org-reveal t)
    (org-show-entry)
    (outline-show-children)))
#+END_SRC

** YAML

#+BEGIN_SRC emacs-lisp
(use-package yaml-mode)
#+END_SRC

* Features

** Completion

*** Consult

Provide various commands to list and /consult/ existing collections.

#+BEGIN_SRC emacs-lisp
(use-package consult
  :bind
  ([remap goto-line] . consult-goto-line)
  ([remap isearch-forward] . consult-line)
  ([remap switch-to-buffer] . consult-buffer)
  ("C-h M" . consult-minor-mode-menu)
  :custom
  (consult-line-start-from-top t)
  (consult-project-root-function #'me/project-root)
  (xref-show-definitions-function #'consult-xref)
  (xref-show-xrefs-function #'consult-xref)
  :hook
  (org-mode . (lambda () (setq-local consult-fontify-preserve nil)))
  :init
  (with-eval-after-load 'evil
    (evil-global-set-key 'motion "gm" #'consult-mark)
    (evil-global-set-key 'motion "gM" #'consult-imenu)
    (evil-global-set-key 'motion "go" #'consult-outline)))
#+END_SRC

*** Corfu

Minimal completion-at-point. This is an experiment to try and replace the
heavier =company= alternative. With =display-line-numbers-type=, prefer the
='visual= value as ='relative= numbers break when the completion overlay opens.

#+BEGIN_SRC emacs-lisp
(use-package corfu
  :hook
  (after-init . global-corfu-mode)
  :custom
  (corfu-auto t)
  (corfu-auto-delay .5))
#+END_SRC

*** Marginalia

#+BEGIN_SRC emacs-lisp
(use-package marginalia
  :hook
  (after-init . marginalia-mode))
#+END_SRC

*** Orderless

Allow completion based on space-separated tokens, out of order.

#+BEGIN_SRC emacs-lisp
(use-package orderless
  :custom
  (completion-styles '(orderless))
  (orderless-component-separator 'orderless-escapable-split-on-space))
#+END_SRC

*** Vertico

Prettify the completion minibuffer featuring keyboard-driven vertical navigation
with live-reload.

#+BEGIN_SRC emacs-lisp
(use-package vertico
  :custom
  (vertico-count-format '("%-5s " . "%2$s"))
  (vertico-resize nil)
  :hook
  (after-init . vertico-mode))
#+END_SRC

** Comments

Comment things using Evil operators.

#+BEGIN_SRC emacs-lisp
(use-package evil-commentary
  :hook
  (evil-mode . evil-commentary-mode))
#+END_SRC

Customize the way default comments should be handled.

#+BEGIN_SRC emacs-lisp
(use-package newcomment
  :straight nil
  :bind
  ("M-<return>" . comment-indent-new-line)
  :hook
  (prog-mode . (lambda () (setq-local comment-auto-fill-only-comments t)))
  :custom
  (comment-multi-line t))
#+END_SRC

** Context Actions

*** Embark

#+BEGIN_SRC emacs-lisp
(use-package embark
  :bind
  ("C-;" . embark-act)
  ([remap describe-bindings] . embark-bindings)
  :custom
  (embark-indicators
   '(embark-highlight-indicator
     embark-isearch-highlight-indicator
     embark-minimal-indicator))
  (prefix-help-command #'embark-prefix-help-command))
#+END_SRC

*** Selected

Enable new custom binds when region is active. I've also added a few helpers to
use with =selected=.

| TODO | Bind these to the =evil-visual= map |

#+BEGIN_SRC emacs-lisp
(use-package selected
  :bind*
  (:map selected-keymap
   ("<"           . mc/mark-previous-like-this)
   (">"           . mc/mark-next-like-this)
   ("C-<"         . mc/unmark-previous-like-this)
   ("C->"         . mc/unmark-next-like-this)
   ("M-<"         . mc/skip-to-previous-like-this)
   ("M->"         . mc/skip-to-next-like-this)
   ("C-c >"       . mc/edit-lines)
   ("C-c c"       . capitalize-region)
   ("C-c k"       . barrinalo-kebab)
   ("C-c l"       . downcase-region)
   ("C-c u"       . upcase-region)
   ("C-f"         . fill-region)
   ("C-h h"       . hlt-highlight-region)
   ("C-h H"       . hlt-unhighlight-region)
   ("C-p"         . webpaste-paste-region)
   ("C-q"         . selected-off)
   ("C-s r"       . barrinalo-reverse)
   ("C-s s"       . sort-lines)
   ("C-s w"       . barrinalo-sort-words)
   ("C-<tab>"     . me/pretty-print)
   ("M-<left>"    . barrinalo-indent-leftward)
   ("M-<right>"   . barrinalo-indent-rightward)
   ("M-S-<left>"  . barrinalo-indent-leftward-tab)
   ("M-S-<right>" . barrinalo-indent-rightward-tab))
  :hook
  (after-init . selected-global-mode)
  :config
  (require 'barrinalo)
  (require 'browse-url)
  :custom
  (selected-minor-mode-override t))
#+END_SRC

#+BEGIN_SRC emacs-lisp
(defvar-local me/pretty-print-function nil)

(defun me/pretty-print (beg end)
  (interactive "r")
  (if me/pretty-print-function
      (progn (funcall me/pretty-print-function beg end)
             (setq deactivate-mark t))
    (user-error "[Dotemacs] `me/pretty-print-function' is not set")))
#+END_SRC

** Diff

Ediff is a visual interface to Unix =diff=.

#+BEGIN_SRC emacs-lisp
(use-package ediff-wind
  :straight nil
  :custom
  (ediff-split-window-function #'split-window-horizontally)
  (ediff-window-setup-function #'ediff-setup-windows-plain))
#+END_SRC

** Dired

Configure Dired buffers. Amongst many other things, Emacs is also a file
explorer.

| TODO | Check out =dired-collapse=       |
| TODO | Check out =dired-imenu=          |
| TODO | Make =dired-bob= and =dired-eob= |

#+BEGIN_SRC emacs-lisp
(use-package dired
  :straight nil
  :hook
  (dired-mode . dired-hide-details-mode)
  :bind
  (:map dired-mode-map
   ("C-<return>" . me/dired-open-externally))
  :custom
  (dired-auto-revert-buffer t)
  (dired-dwim-target t)
  (dired-hide-details-hide-symlink-targets nil)
  (dired-listing-switches "-agho --group-directories-first")
  (dired-kill-when-opening-new-dired-buffer t)
  (dired-recursive-copies 'always))
#+END_SRC

#+BEGIN_SRC emacs-lisp
(defun me/dired-open-externally (argument)
  "Open file under point with an external program.
With positive ARGUMENT, prompt for the command to use."
  (interactive "P")
  (let* ((file (dired-get-file-for-visit))
         (command (and (not argument)
                       (pcase system-type
                         ('darwin "open")
                         ((or 'gnu 'gnu/kfreebsd 'gnu/linux) "xdg-open"))))
         (command (or command (read-shell-command "Open with: "))))
    (call-process command nil 0 nil file)))
#+END_SRC

** Documentation

When [[https://debbugs.gnu.org/cgi/bugreport.cgi?bug=47109][this patch]] is
sorted out, we'll be able to use a new format function to have pieces of
documentation joined with a horizontal rule. eg.

#+BEGIN_SRC emacs-lisp :tangle no
(setq-default
 eldoc-documentation-format-function #'eldoc-documentation-format-concat-hr)
#+END_SRC

#+BEGIN_SRC emacs-lisp
(use-package eldoc
  :straight nil
  :custom
  (eldoc-documentation-strategy 'eldoc-documentation-compose-eagerly)
  (eldoc-echo-area-prefer-doc-buffer t)
  (eldoc-idle-delay .1))
#+END_SRC

** Evil

Evil emulates and manages the infamous Vim states and motions ported to Emacs.

| TODO | Make transient maps for buffer motions and =winner= commands |

#+BEGIN_SRC emacs-lisp
(use-package evil
  :bind
  (:map evil-inner-text-objects-map
   ("g" . me/evil-buffer)
   :map evil-outer-text-objects-map
   ("g" . me/evil-buffer)
   :map evil-insert-state-map
   ("C-a" . nil)                        ; Free Readline key
   ("C-e" . nil)                        ; Free Readline key
   ("C-w" . nil)                        ; Free kill command
   :map evil-motion-state-map
   ("RET" . nil)                        ; Free return command
   ("gb" . switch-to-buffer)
   ("gB" . project-switch-to-buffer)
   ("gC" . describe-face)
   ("gp" . project-switch-project)
   ("gr" . (lambda () (interactive) (revert-buffer nil t)))
   ("gs" . avy-goto-char-timer)
   ("gS" . avy-goto-char)
   ("q" . nil)                          ; Free quit command
   ("C-e" . nil)                        ; Free Readline key
   ("C-]" . nil)                        ; Free abort edit command
   :map evil-normal-state-map
   ("q" . nil)                          ; Free quit command
   ("gd" . dired-jump)
   ("gD" . project-dired)
   ("gf" . find-file)
   ("gF" . project-find-file)
   ("M-." . nil)                        ; Free xref command
   :map evil-visual-state-map
   ("f" . fill-region)
   :map evil-window-map
   ("u" . winner-undo)
   ("C-r" . winner-redo))
  :hook
  (after-init . evil-mode)
  (after-save . evil-normal-state)
  :custom
  (evil-echo-state nil)
  (evil-emacs-state-cursor (default-value 'cursor-type))
  (evil-undo-system 'undo-redo)
  (evil-visual-state-cursor 'hollow)
  (evil-want-keybinding nil)
  :config
  (add-to-list 'evil-emacs-state-modes 'exwm-mode)
  (add-to-list 'evil-emacs-state-modes 'dired-mode)
  (add-to-list 'evil-emacs-state-modes 'process-menu-mode)
  (add-to-list 'evil-emacs-state-modes 'profiler-report-mode)
  (add-to-list 'evil-emacs-state-modes 'vterm-mode)
  (add-to-list 'evil-insert-state-modes 'with-editor-mode)
  (add-to-list 'evil-motion-state-modes 'helpful-mode)
  (evil-define-text-object me/evil-buffer (_count &optional _begin _end type)
    "Text object to represent the whole buffer."
    (evil-range (point-min) (point-max) type))
  (advice-add 'evil-indent :around #'me/evil-indent))
#+END_SRC

#+BEGIN_SRC emacs-lisp
(defun me/evil-indent (original &rest arguments)
  "Like `evil-indent' but save excursion."
  (save-excursion (apply original arguments)))
#+END_SRC

Emulate =vim-surround=. Take actions with surrounding pairs.

#+BEGIN_SRC emacs-lisp
(use-package evil-surround
  :hook
  (evil-mode . evil-surround-mode))
#+END_SRC

Activate volatile keymaps for split sizing.

| TODO | Use =repeat-mode= instead |

#+BEGIN_SRC emacs-lisp
(defun me/evil-window-resize-continue (&optional _count)
  "Activate a sparse keymap for evil window resizing routines in order to
support repeated key strokes."
  (set-transient-map
   (let ((map (make-sparse-keymap)))
     (define-key map (kbd "-") #'evil-window-decrease-height)
     (define-key map (kbd "+") #'evil-window-increase-height)
     (define-key map (kbd "<") #'evil-window-decrease-width)
     (define-key map (kbd ">") #'evil-window-increase-width)
     map)))

(advice-add 'evil-window-decrease-height :after #'me/evil-window-resize-continue)
(advice-add 'evil-window-increase-height :after #'me/evil-window-resize-continue)
(advice-add 'evil-window-decrease-width :after #'me/evil-window-resize-continue)
(advice-add 'evil-window-increase-width :after #'me/evil-window-resize-continue)
#+END_SRC

** Expand

HippieExpand manages expansions a la [[http://emmet.io/][Emmet]]. So I've
gathered all features that look anywhere close to this behavior for it to handle
them under the same bind, that is =<C-return>=. It's basically an expand DWIM.

#+BEGIN_SRC emacs-lisp
(use-package emmet-mode
  :bind
  (:map emmet-mode-keymap
   ("C-<return>" . nil))
  :hook
  (css-mode . emmet-mode)
  (html-mode . emmet-mode)
  (typescript-tsx-mode . emmet-mode)
  :custom
  (emmet-insert-flash-time .1)
  (emmet-jsx-className-braces? t)
  (emmet-move-cursor-between-quote t)
  :preface
  (defun me/emmet-try-expand (args)
    "Try `emmet-expand-line' if `emmet-mode' is active. Else, does nothing."
    (interactive "P")
    (when emmet-mode (emmet-expand-line args))))
#+END_SRC

#+BEGIN_SRC emacs-lisp
(use-package hippie-exp
  :straight nil
  :bind
  ("C-<return>" . hippie-expand)
  :custom
  (hippie-expand-try-functions-list
   '(yas-hippie-try-expand me/emmet-try-expand))
  (hippie-expand-verbose nil))
#+END_SRC

#+BEGIN_SRC emacs-lisp
(use-package yasnippet
  :bind
  (:map yas-minor-mode-map
   ("TAB" . nil)
   ([tab] . nil))
  :hook
  (prog-mode . yas-minor-mode)
  (text-mode . yas-minor-mode)
  :custom
  (yas-verbosity 2)
  :config
  (yas-reload-all))
#+END_SRC

** Help

Bind useful commands in help buffers.

#+BEGIN_SRC emacs-lisp
(use-package help-fns
  :straight nil
  :bind
  ("C-h K" . describe-keymap))
#+END_SRC

#+BEGIN_SRC emacs-lisp
(use-package help-mode
  :straight nil
  :bind
  (:map help-mode-map
   ("<" . help-go-back)
   (">" . help-go-forward))
  :config
  (with-eval-after-load 'evil
    (evil-define-key* 'motion help-mode-map
      (kbd "<tab>") #'forward-button)))
#+END_SRC

Provide better detailed help buffers.

#+BEGIN_SRC emacs-lisp
(use-package helpful
  :bind
  ([remap describe-command] . helpful-command)
  ([remap describe-function] . helpful-callable)
  ([remap describe-key] . helpful-key)
  ([remap describe-symbol] . helpful-symbol)
  ([remap describe-variable] . helpful-variable)
  ("C-h F" . helpful-function)
  :config
  (with-eval-after-load 'evil
    (evil-define-key* 'motion helpful-mode-map
      (kbd "gr") #'helpful-update
      (kbd "<tab>") #'forward-button)))
#+END_SRC

** Hydra

Hydra allows me to group binds together. It also shows a list of all implemented
commands in the echo area.

#+BEGIN_QUOTE
Once you summon the Hydra through the prefixed binding (the body + any one
head), all heads can be called in succession with only a short extension.

The Hydra is vanquished once Hercules, any binding that isn't the Hydra's head,
arrives. Note that Hercules, besides vanquishing the Hydra, will still serve his
original purpose, calling his proper command. This makes the Hydra very
seamless, it's like a minor mode that disables itself auto-magically.

--- Oleh Krehel
#+END_QUOTE

*** Hydra: Bootstrap

Augments and bootstrap helpers for =hydra=. Work in progress.

#+BEGIN_SRC emacs-lisp
(use-package hercules
  :demand
  :load-path "lisp/hercules"
  :straight nil)
#+END_SRC

#+BEGIN_SRC emacs-lisp
(use-package hydra
  :bind
  ("C-c d" . hydra-dates/body)
  ("C-c g" . hydra-git/body)
  ("C-c i" . hydra-interface/body)
  ("C-c p" . hydra-project/body)
  ("C-c s" . hydra-system/body)
  ("C-c v" . hydra-visit/body)
  :custom
  (hydra-default-hint nil))
#+END_SRC

*** Hydra: Dates

Group date-related commands.

#+BEGIN_SRC emacs-lisp
(defhydra hydra-dates (:color teal)
  (concat (hercules-heading "Insert" "Insert with Time") "
 _d_ short           _D_ short           ^^
 _i_ iso             _I_ iso             ^^
 _l_ long            _L_ long            ^^")
  ("q" nil)
  ("d" me/date-short)
  ("D" me/date-short-with-time)
  ("i" me/date-iso)
  ("I" me/date-iso-with-time)
  ("l" me/date-long)
  ("L" me/date-long-with-time))
#+END_SRC

*** Hydra: Git

Group =git= commands.

#+BEGIN_SRC emacs-lisp
(defhydra hydra-git (:color teal)
  (concat (hercules-heading "Do" "Gutter") "
 _b_ blame           _p_ previous        ^^
 _c_ clone           _n_ next            ^^
 _g_ status          _r_ revert          ^^
 _m_ smerge...       _s_ stage           ^^")
  ("q" nil)
  ("b" magit-blame)
  ("c" magit-clone)
  ("g" magit-status)
  ("m" (progn (require 'smerge-mode) (hydra-git--smerge/body)))
  ("n" git-gutter:next-hunk :color red)
  ("p" git-gutter:previous-hunk :color red)
  ("r" git-gutter:revert-hunk)
  ("s" git-gutter:stage-hunk :color red))
#+END_SRC

Group =smerge= commands under the Git hydra.

#+BEGIN_SRC emacs-lisp
(defhydra hydra-git--smerge (:color pink
                             :pre (if (not smerge-mode) (smerge-mode 1))
                             :post (smerge-auto-leave))
  (concat (hercules-heading "Move" "Keep" "Diff") "
 _g_ first           _RET_ current       _<_ upper / base
 _G_ last            _a_ all             _=_ upper / lower
 _j_ next            _b_ base            _>_ base / lower
 _k_ previous        _l_ lower           _E_ ediff
 ^^                  _u_ upper           _H_ highlight")
  ("q" nil :color blue)
  ("j" smerge-next)
  ("k" smerge-prev)
  ("<" smerge-diff-base-upper :color blue)
  ("=" smerge-diff-upper-lower :color blue)
  (">" smerge-diff-base-lower :color blue)
  ("RET" smerge-keep-current)
  ("a" smerge-keep-all)
  ("b" smerge-keep-base)
  ("E" smerge-ediff :color blue)
  ("g" (progn (goto-char (point-min)) (smerge-next)))
  ("G" (progn (goto-char (point-max)) (smerge-prev)))
  ("H" smerge-refine)
  ("l" smerge-keep-lower)
  ("u" smerge-keep-upper))
#+END_SRC

*** Hydra: Interface

Group interface-related commands.

| TODO | Check out =defhydradio=                               |
| TODO | Improve =hercules-heading= to accept a list of fields |

#+BEGIN_SRC emacs-lisp
(defhydra hydra-interface (:color pink)
  (concat (hercules-heading "Do" "Zoom" "Toggles") "
 _m_ maximize frame  _-_ out             _n_ mode: %s`display-line-numbers
 _M_ center frame    _=_ in              _o_ olivetti: %s`widowmaker-olivetti-automatic
 _t_ cycle theme     _0_ reset           _O_ olivetti width: %s`olivetti-body-width")
  ("q" nil)
  ("-" default-text-scale-decrease)
  ("=" default-text-scale-increase)
  ("0" default-text-scale-reset :color blue)
  ("m" toggle-frame-maximized :color blue)
  ("M" widowmaker-placement-center :color blue)
  ("n" ruric-toggle-line-numbers)
  ("o" widowmaker-olivetti-automatic-toggle :color blue)
  ("O" widowmaker-olivetti-body-reset :color blue)
  ("<" widowmaker-olivetti-body-less)
  (">" widowmaker-olivetti-body-more)
  ("t" morophon-cycle :color blue)
  ("T" morophon-cycle))
#+END_SRC

*** Hydra: Project

Group project-related commands.

#+BEGIN_SRC emacs-lisp
(defhydra hydra-project (:color teal)
  (concat (hercules-heading "Do" "Find" "Search") "
 _K_ kill buffers    _d_ directory       _r_ replace
 _t_ forget project  _D_ root            _s_ ripgrep
 _T_ prune projects  _f_ file            ^^
 ^^                  _p_ project         ^^")
  ("q" nil)
  ("d" project-find-dir)
  ("D" project-dired)
  ("f" project-find-file)
  ("K" project-kill-buffers)
  ("p" project-switch-project)
  ("r" project-query-replace-regexp)
  ("s" me/project-search)
  ("t" project-forget-project)
  ("T" project-forget-zombie-projects))
#+END_SRC

*** Hydra: System

Group system-related commands.

#+BEGIN_SRC emacs-lisp
(defhydra hydra-system (:color teal)
  (concat (hercules-heading "Do" "Packages" "Toggles") "
 _d_ clear compiled  _p_ install         _g_ debug: %-3s`debug-on-error
 _D_ clear desktop   _P_ prune           ^^
 _l_ processes       _u_ update          ^^
 _Q_ clear and kill  _U_ update all      ^^")
  ("q" nil)
  ("d" me/byte-delete)
  ("D" desktop-remove)
  ("g" (setq debug-on-error (not debug-on-error)))
  ("l" list-processes)
  ("p" straight-use-package)
  ("P" (progn (straight-remove-unused-repos) (straight-prune-build)))
  ("Q" (let ((desktop-save nil))
         (me/byte-delete)
         (desktop-remove)
         (save-buffers-kill-terminal)))
  ("u" straight-pull-package)
  ("U" straight-pull-all))
#+END_SRC

#+BEGIN_SRC emacs-lisp
(defun me/byte-delete ()
  "Find all byte-compiled files under the current directory and delete them."
  (interactive)
  (shell-command "find . -name \"*.elc\" -type f | xargs rm -f"))
#+END_SRC

*** Hydra: Visit

Group shortcuts for often-accessed configuration files.

#+BEGIN_SRC emacs-lisp
(defhydra hydra-visit (:color teal)
  (concat (hercules-heading "Visit") "
 _d_ qtile           _l_ linux           _s_ zsh
 _e_ emacs           _n_ dunst           _t_ kitty")
  ("q" nil)
  ("d" (find-file "~/Workspace/dot/config/qtile.org"))
  ("e" (find-file (concat user-emacs-directory "dotemacs.org")))
  ("l" (find-file "~/Workspace/dot/LINUX.org"))
  ("n" (find-file "~/Workspace/dot/config/dunst.org"))
  ("s" (find-file "~/Workspace/dot/config/zsh.org"))
  ("t" (find-file "~/Workspace/dot/config/kitty.org")))
#+END_SRC

** Intellisense

*** Code References

Find code references throughout a codebase.

#+BEGIN_SRC emacs-lisp
(use-package xref
  :straight nil
  :config
  (with-eval-after-load 'evil
    (evil-define-key* 'motion xref--xref-buffer-mode-map
      (kbd "<backtab") #'xref-prev-group
      (kbd "<return") #'xref-goto-xref
      (kbd "<tab>") #'xref-next-group)))
#+END_SRC

*** Language Server Protocol

Yup, Emacs supports LSP.

#+BEGIN_SRC emacs-lisp
(use-package eglot
  :custom
  (eglot-autoshutdown t)
  :hook
  (typescript-mode . eglot-ensure)
  :init
  (put 'eglot-server-programs 'safe-local-variable 'listp)
  :config
  (add-to-list 'eglot-stay-out-of 'eldoc-documentation-strategy)
  (put 'eglot-error 'flymake-overlay-control nil)
  (put 'eglot-warning 'flymake-overlay-control nil)
  (advice-add 'eglot--apply-workspace-edit :after #'me/project-save)
  (advice-add 'project-kill-buffers :before #'me/eglot-shutdown-project)
  :preface
  (defun me/eglot-shutdown-project ()
    "Kill the LSP server for the current project if it exists."
    (when-let ((server (eglot-current-server)))
      (eglot-shutdown server))))
#+END_SRC

This package provides a new =consult= command to browse LSP symbols with the
=workspace/symbol= procedure within the current project.

#+BEGIN_SRC emacs-lisp
(use-package consult-eglot
  :init
  (with-eval-after-load 'evil
    (evil-define-key 'motion eglot-mode-map
      (kbd "go") #'consult-eglot-symbols)))
#+END_SRC

*** Linters

#+BEGIN_SRC emacs-lisp
(use-package flymake
  :straight nil
  :custom
  (flymake-fringe-indicator-position nil))
#+END_SRC

*** Tree-Sitter

Use [[https://tree-sitter.github.io/tree-sitter/][Tree-sitter]] to handle more
complex syntax trees where the default alternatives lack the highlighting power.

#+BEGIN_SRC emacs-lisp
(use-package tree-sitter
  :hook
  (js-mode . tree-sitter-hl-mode)
  (typescript-mode . tree-sitter-hl-mode)
  (typescript-tsx-mode . tree-sitter-hl-mode))

(use-package tree-sitter-langs
  :after tree-sitter
  :defer nil
  :config
  (tree-sitter-require 'tsx)
  (add-to-list 'tree-sitter-major-mode-language-alist
               '(typescript-tsx-mode . tsx)))
#+END_SRC

** Line Numbers

Display relative line numbers in most editing modes.

#+BEGIN_SRC emacs-lisp
(add-hook 'conf-mode-hook #'display-line-numbers-mode)
(add-hook 'prog-mode-hook #'display-line-numbers-mode)
(add-hook 'text-mode-hook #'display-line-numbers-mode)
(setq-default
 display-line-numbers-grow-only t
 display-line-numbers-type 'relative
 display-line-numbers-width 3)
#+END_SRC

** Linters

Run Prettier against the whole buffer on save. See the
[[#directory-local-variables][Directory-Local Variables]] section for automatic
enabling of the minor mode.

#+BEGIN_SRC emacs-lisp
(use-package prettier
  :config
  (add-to-list 'prettier-enabled-parsers 'json-stringify))
#+END_SRC

** Mode-Line

Prettify the mode-line with customizable and conditional segments.

| TODO | Make a =arecord -vvv -f dat /dev/null= segment |

#+BEGIN_SRC emacs-lisp
(use-package doom-modeline
  :demand t
  :custom
  (doom-modeline-bar-width 1)
  (doom-modeline-buffer-file-name-style 'truncate-with-project)
  (doom-modeline-height (szadek-get 'mode-line-height 36))
  (doom-modeline-enable-word-count t)
  (doom-modeline-major-mode-icon nil)
  (doom-modeline-percent-position nil)
  (doom-modeline-vcs-max-length 28)
  :config
  (doom-modeline-def-segment me/buffer
    "The buffer description and major mode icon."
    (concat (doom-modeline--buffer-name) doom-modeline-spc))
  (doom-modeline-def-segment me/buffer-position
    "The buffer position."
    (let* ((active (doom-modeline--active))
           (face (if active 'mode-line 'mode-line-inactive)))
      (propertize (concat doom-modeline-spc
                          (format-mode-line "%l:%c")
                          doom-modeline-spc)
                  'face face)))
  (doom-modeline-def-segment me/buffer-simple
    "The buffer name but simpler."
    (let* ((active (doom-modeline--active))
           (face (cond ((and buffer-file-name (buffer-modified-p))
                        'doom-modeline-buffer-modified)
                       (active 'doom-modeline-buffer-file)
                       (t 'mode-line-inactive))))
      (concat (propertize "%b" 'face face) doom-modeline-spc)))
  (doom-modeline-def-segment me/default-directory
    "The buffer directory."
    (let* ((active (doom-modeline--active))
           (face (if active 'doom-modeline-buffer-path 'mode-line-inactive)))
      (concat doom-modeline-spc
              (propertize (abbreviate-file-name default-directory) 'face face)
              doom-modeline-spc)))
  (doom-modeline-def-segment me/flymake
    "The error status with color codes and icons."
    (when (bound-and-true-p flymake-mode)
      (let ((active (doom-modeline--active))
            (icon doom-modeline--flymake-icon)
            (text doom-modeline--flymake-text))
        (concat
         (when icon
           (concat doom-modeline-spc
                   (if active
                       icon
                     (doom-modeline-propertize-icon icon 'mode-line-inactive))))
         (when text
           (concat (if icon doom-modeline-vspc doom-modeline-spc)
                   (if active
                       text
                     (propertize text 'face 'mode-line-inactive))))
         (when (or icon text)
           doom-modeline-spc)))))
  (doom-modeline-def-segment me/info
    "The topic and nodes in Info buffers."
    (let ((active (doom-modeline--active)))
      (concat
       (propertize " (" 'face (if active 'mode-line 'mode-line-inactive))
       (propertize (if (stringp Info-current-file)
                       (replace-regexp-in-string
                        "%" "%%" (file-name-sans-extension
                                  (file-name-nondirectory Info-current-file)))
                     (format "*%S*" Info-current-file))
                   'face (if active 'doom-modeline-info 'mode-line-inactive))
       (propertize ") " 'face (if active 'mode-line 'mode-line-inactive))
       (when Info-current-node
         (propertize (concat
                      (replace-regexp-in-string "%" "%%" Info-current-node)
                      doom-modeline-spc)
                     'face (if active
                               'doom-modeline-buffer-path
                             'mode-line-inactive))))))
  (doom-modeline-def-segment me/major-mode
    "The current major mode, including environment information."
    (let* ((active (doom-modeline--active))
           (face (if active
                     'doom-modeline-buffer-major-mode
                   'mode-line-inactive)))
      (concat doom-modeline-spc
              (propertize (format-mode-line mode-name) 'face face)
              doom-modeline-spc)))
  (doom-modeline-def-segment me/process
    "The ongoing process details."
    (let ((result (format-mode-line mode-line-process)))
      (concat (if (doom-modeline--active)
                  result
                (propertize result 'face 'mode-line-inactive))
              doom-modeline-spc)))
  (doom-modeline-def-segment me/vcs
    "The version control system information."
    (when-let ((branch doom-modeline--vcs-text))
      (let ((active (doom-modeline--active))
            (text (concat ":" branch)))
        (concat doom-modeline-spc
                (if active text (propertize text 'face 'mode-line-inactive))
                doom-modeline-spc))))
  (doom-modeline-mode 1)
  (doom-modeline-def-modeline 'info
    '(bar modals me/buffer me/info me/buffer-position selection-info)
    '(irc-buffers matches me/process debug me/major-mode workspace-name))
  (doom-modeline-def-modeline 'main
    '(bar modals me/buffer remote-host me/buffer-position me/flymake
      selection-info)
    '(irc-buffers matches me/process me/vcs debug me/major-mode workspace-name))
  (doom-modeline-def-modeline 'message
    '(bar modals me/buffer-simple me/buffer-position selection-info)
    '(irc-buffers matches me/process me/major-mode workspace-name))
  (doom-modeline-def-modeline 'org-src
    '(bar modals me/buffer-simple me/buffer-position me/flymake selection-info)
    '(irc-buffers matches me/process debug me/major-mode workspace-name))
  (doom-modeline-def-modeline 'project
    '(bar modals me/default-directory)
    '(irc-buffers matches me/process debug me/major-mode workspace-name))
  (doom-modeline-def-modeline 'special
    '(bar modals me/buffer me/buffer-position selection-info)
    '(irc-buffers matches me/process debug me/major-mode workspace-name))
  (doom-modeline-def-modeline 'vcs
    '(bar modals me/buffer remote-host me/buffer-position selection-info)
    '(irc-buffers matches me/process debug me/major-mode workspace-name)))
#+END_SRC

** Multiple Cursors

Add support for multiple cursors within Evil.

#+BEGIN_SRC emacs-lisp
(use-package evil-multiedit
  :bind
  (:map evil-insert-state-map
   ("M-d". evil-multiedit-toggle-marker-here)
   :map evil-normal-state-map
   ("M-d". evil-multiedit-match-and-next)
   ("M-D". evil-multiedit-match-and-prev)
   :map evil-multiedit-state-map
   ("C-p". evil-multiedit-prev)
   ("C-n". evil-multiedit-next)
   :map evil-multiedit-insert-state-map
   ("C-n". evil-multiedit-next)
   ("C-p". evil-multiedit-prev)))
#+END_SRC

Enable multiple cursors outside Evil. Some witchcraft at work here.

| TODO | Fix =mc/keymap= not always being on top |

#+BEGIN_SRC emacs-lisp
(use-package multiple-cursors
  :bind*
  (:map mc/keymap
   ("M-a" . mc/vertical-align-with-space)
   ("M-h" . mc-hide-unmatched-lines-mode)
   ("M-l" . mc/insert-letters)
   ("M-n" . mc/insert-numbers))
  :init
  (setq-default mc/list-file (shelldock "multiple-cursors.el"))
  :custom
  (mc/edit-lines-empty-lines 'ignore)
  (mc/insert-numbers-default 1))
#+END_SRC

** Navigation

#+BEGIN_QUOTE
=avy= is a GNU Emacs package for jumping to visible text using a char-based
decision tree. See also =ace-jump-mode= and =vim-easymotion= -- =avy= uses the
same idea.

--- Oleh Krehel
#+END_QUOTE

#+BEGIN_SRC emacs-lisp
(use-package avy
  :custom
  (avy-background t)
  (avy-style 'at-full)
  (avy-timeout-seconds .3))
#+END_SRC

#+BEGIN_QUOTE
Evil-snipe emulates =vim-seek= and/or =vim-sneak= in =evil-mode=.

--- Henrik Lissner
#+END_QUOTE

#+BEGIN_SRC emacs-lisp
(use-package evil-snipe
  :hook
  (evil-mode . evil-snipe-mode)
  (evil-mode . evil-snipe-override-mode)
  :custom
  (evil-snipe-char-fold t)
  (evil-snipe-repeat-scope 'visible)
  (evil-snipe-smart-case t))
#+END_SRC

I disagree with some of Emacs' opinion with regards to paragraphs amongst other
things. =hanna= is a collection of replacements for the aforementioned defaults.

#+BEGIN_SRC emacs-lisp
(use-package hanna
  :load-path "lisp/hanna"
  :straight nil
  :bind
  ([remap move-beginning-of-line] . hanna-beginning-of-line)
  ([remap backward-paragraph] . hanna-paragraph-backward)
  ([remap forward-paragraph] . hanna-paragraph-forward))
#+END_SRC

Isearch stands for /incremental search/. This means that search results are
updated and highlighted while you are typing your query, incrementally.

#+BEGIN_SRC emacs-lisp
(use-package isearch
  :straight nil
  :bind
  (("C-S-r" . isearch-backward-regexp)
   ("C-S-s" . isearch-forward-regexp))
  :custom
  (isearch-allow-scroll t)
  (lazy-highlight-buffer t)
  (lazy-highlight-cleanup nil)
  (lazy-highlight-initial-delay 0)
  :hook
  (isearch-update-post . me/isearch-aim-beginning)
  :preface
  (defun me/isearch-aim-beginning ()
    "Move cursor back to the beginning of the current match."
    (when (and isearch-forward (number-or-marker-p isearch-other-end))
      (goto-char isearch-other-end))))
#+END_SRC

Customize the scrolling behavior using the mouse wheel.

#+BEGIN_SRC emacs-lisp
(use-package mwheel
  :straight nil
  :custom
  (mouse-wheel-progressive-speed nil)
  (mouse-wheel-scroll-amount '(2 ((control) . 8)))
  :config
  (advice-add 'mwheel-scroll :around
    (defun me/mwheel-scroll (original &rest arguments)
      "Like `mwheel-scroll' but preserve screen position."
      (let ((scroll-preserve-screen-position :always))
        (apply original arguments)))))
#+END_SRC

Pulse strategic locations in the current buffer for readability and focus
purposes.

#+BEGIN_SRC emacs-lisp
(use-package pulsar
  :defer 1
  :hook
  (after-init . pulsar-global-mode))
#+END_SRC

** OS-Specific

Initialize environment variables.

#+BEGIN_QUOTE
Ever find that a command works in your shell, but not in Emacs?

This happens a lot on OS X, where an Emacs instance started from the GUI
inherits a default set of environment variables.

This library works solves this problem by copying important environment
variables from the user's shell: it works by asking your shell to print out the
variables of interest, then copying them into the Emacs environment.

--- Steve Purcell
#+END_QUOTE

| TODO | Figure out how to feed nvm path from a non-interactive shell |

#+BEGIN_SRC emacs-lisp
(use-package exec-path-from-shell
  :if (eq window-system 'ns)
  :hook
  (after-init . exec-path-from-shell-initialize))
#+END_SRC

Augment Emacs experience for MacOS users.

#+BEGIN_SRC emacs-lisp
(when (eq system-type 'darwin)
  (setq-default
   ns-alternate-modifier 'super         ; Map Super to the Alt key
   ns-command-modifier 'meta            ; Map Meta to the Cmd key
   ns-pop-up-frames nil                 ; Always re-use the same frame
   ns-use-mwheel-momentum nil))         ; Disable smooth scroll
#+END_SRC

Provide a way to invoke =bash= on Windows. This requires /Developer Mode/ to be
enabled in the first place.

#+BEGIN_SRC emacs-lisp
(when (eq system-type 'windows-nt)
  (defun me/bash ()
    "Run Bash executable under System32."
    (interactive)
    (let ((explicit-shell-file-name "C:/Windows/System32/bash.exe"))
      (shell))))
#+END_SRC

** Pair-Programming

Adjust font size for all windows at once.

#+BEGIN_QUOTE
This package provides commands for increasing or decreasing the default font
size in all GUI Emacs frames -- it is like an Emacs-wide version of
=text-scale-mode=.

--- Steve Purcell
#+END_QUOTE

#+BEGIN_SRC emacs-lisp
(use-package default-text-scale)
#+END_SRC

When broadcasting your Emacs session over video online it can be useful to tone
down the Emacs'ness. Summon the two-headed ogre Ruric with =M-x ruric-mode= and
start your pair-programming session.

#+BEGIN_SRC emacs-lisp
(use-package ruric
  :commands
  (ruric-global-mode
   ruric-mode
   ruric-toggle-line-numbers
   ruric-toggle-line-numbers-absolute)
  :load-path "lisp/ruric"
  :straight nil)
#+END_SRC

** Parentheses

Highlight parenthese-like delimiters in a rainbow fashion. It eases the reading
when dealing with mismatched parentheses.

#+BEGIN_SRC emacs-lisp
(use-package rainbow-delimiters
  :hook
  (prog-mode . rainbow-delimiters-mode))
#+END_SRC

I am still looking for the perfect parenthesis management setup as of today...
No package seem to please my person.

#+BEGIN_SRC emacs-lisp
(use-package smartparens
  :bind
  ("M-<backspace>" . sp-unwrap-sexp)
  ("M-<left>" . sp-forward-barf-sexp)
  ("M-<right>" . sp-forward-slurp-sexp)
  ("M-S-<left>" . sp-backward-slurp-sexp)
  ("M-S-<right>" . sp-backward-barf-sexp)
  :hook
  (after-init . smartparens-global-mode)
  (wdired-mode . smartparens-mode)
  :custom
  (sp-highlight-pair-overlay nil)
  (sp-highlight-wrap-overlay nil)
  (sp-highlight-wrap-tag-overlay nil)
  :config
  (show-paren-mode 0)
  (require 'smartparens-config))
#+END_SRC

** Paste

#+BEGIN_QUOTE
This mode allows to paste whole buffers or parts of buffers to pastebin-like
services. It supports more than one service and will failover if one service
fails.

--- Elis Hirwing
#+END_QUOTE

| TODO | Handle Org blocks https://github.com/etu/webpaste.el/issues/13 |

#+BEGIN_SRC emacs-lisp
(use-package webpaste
  :custom
  (webpaste-provider-priority '("paste.mozilla.org" "dpaste.org")))
#+END_SRC

** Project

*** Project.el

Provide project-wide commands and utilities.

#+BEGIN_SRC emacs-lisp
(use-package project
  :straight nil
  :custom
  (project-list-file (shelldock "projects.eld"))
  (project-switch-commands
   '((project-dired "Root" "D")
     (project-find-file "File" "f")
     (magit-project-status "Git" "g")
     (me/project-search "Search" "s")
     (widowmaker-terminal-dwim "Terminal" "t"))))
#+END_SRC

#+BEGIN_SRC emacs-lisp
(defun me/project-name (&optional project)
  "Return the name for PROJECT.
If PROJECT is not specified, assume current project root."
  (when-let (root (or project (me/project-root)))
    (file-name-nondirectory
     (directory-file-name
      (file-name-directory root)))))

(defun me/project-save (&rest _)
  "Save file-visiting buffers under the current project root."
  (interactive)
  (save-some-buffers t #'save-some-buffers-root))

(defun me/project-search ()
  "Run ripgrep against project root.
If ripgrep is not installed, use grep instead."
  (interactive)
  (let ((root (me/project-root)))
    (if (not (executable-find "rg"))
        (consult-grep root)
      (message "Could not find executable 'rg', using 'grep' instead")
      (consult-ripgrep root))))

(defun me/project-root ()
  "Return the current project root."
  (when-let (project (project-current))
    (project-root project)))
#+END_SRC

*** Directory-Local Variables

In order to customize specifics directories recursively and without polluting
the Emacs Lisp configuration, one can provide directory-local variables through
a strategically positioned =.dir-locals.el= file or resort to /directory
classes/ for reusability.

Define standard setups for projects that I use on a daily basis.

#+BEGIN_SRC emacs-lisp
(dir-locals-set-class-variables 'prettier
 '((js-mode . ((eval . (prettier-mode))))
   (json-mode . ((eval . (prettier-mode))))
   (scss-mode . ((eval . (prettier-mode))))
   (typescript-mode . ((eval . (prettier-mode))))))
#+END_SRC

Assign paths to specific classes according to specifications found in secrets.

#+BEGIN_SRC emacs-lisp
(mapc (lambda (it) (dir-locals-set-directory-class it 'prettier))
      (szadek-get 'project-prettier))
#+END_SRC

Below is an example of secrets setting no Python project and 2 React projects.
See how to load secrets for more details: [[#load-secrets][Load Secrets]].

#+BEGIN_SRC lisp-data :tangle no
((project-prettier
  . ("~/path/to/react/project/one/"
     "~/path/to/react/project/two/")))
#+END_SRC

Allow specific =eval= form in directory-local mecanisms.

#+BEGIN_SRC emacs-lisp
(add-to-list 'safe-local-eval-forms '(prettier-mode))
(add-to-list 'safe-local-eval-forms '(eglot-ensure))
#+END_SRC

** Quality of Life

Auto-indent code as you write.

#+BEGIN_QUOTE
=electric-indent-mode= is enough to keep your code nicely aligned when all you
do is type. However, once you start shifting blocks around, transposing lines,
or slurping and barfing sexps, indentation is bound to go wrong.

=aggressive-indent-mode= is a minor mode that keeps your code *always* indented.
It reindents after every change, making it more reliable than
electric-indent-mode.

--- Artur Malabarba
#+END_QUOTE

#+BEGIN_SRC emacs-lisp
(use-package aggressive-indent
  :hook
  (css-mode . aggressive-indent-mode)
  (emacs-lisp-mode . aggressive-indent-mode)
  (js-mode . aggressive-indent-mode)
  (lisp-mode . aggressive-indent-mode)
  (lisp-data-mode . aggressive-indent-mode)
  (sgml-mode . aggressive-indent-mode)
  (typescript-mode . aggressive-indent-mode)
  :custom
  (aggressive-indent-comments-too t)
  :config
  (add-to-list 'aggressive-indent-protected-commands 'comment-dwim))
#+END_SRC

A collection of text-changing and transpose functions.

#+BEGIN_SRC emacs-lisp
(use-package barrinalo
  :load-path "lisp/barrinalo"
  :straight nil
  :bind
  ("M-p" . barrinalo-swap-up)
  ("M-n" . barrinalo-swap-down)
  ("M-P" . barrinalo-duplicate-backward)
  ("M-N" . barrinalo-duplicate-forward))
#+END_SRC

Add syntax highlighting support for configuration files.

#+BEGIN_SRC emacs-lisp
(use-package conf-mode
  :straight nil
  :mode (rx (or "CODEOWNERS" (and ".env" (* (and "." (+ word))))) eos))
#+END_SRC

Insert the current date. See [[#hydra-dates][Hydra / Dates]].

#+BEGIN_SRC emacs-lisp
(defun me/date-iso ()
  "Insert the current date, ISO format, eg. 2016-12-09."
  (interactive)
  (insert (format-time-string "%F")))

(defun me/date-iso-with-time ()
  "Insert the current date, ISO format with time, eg. 2016-12-09T14:34:54+0100."
  (interactive)
  (insert (format-time-string "%FT%T%z")))

(defun me/date-long ()
  "Insert the current date, long format, eg. December 09, 2016."
  (interactive)
  (insert (format-time-string "%B %d, %Y")))

(defun me/date-long-with-time ()
  "Insert the current date, long format, eg. December 09, 2016 - 14:34."
  (interactive)
  (insert (capitalize (format-time-string "%B %d, %Y - %H:%M"))))

(defun me/date-short ()
  "Insert the current date, short format, eg. 2016.12.09."
  (interactive)
  (insert (format-time-string "%Y.%m.%d")))

(defun me/date-short-with-time ()
  "Insert the current date, short format with time, eg. 2016.12.09 14:34"
  (interactive)
  (insert (format-time-string "%Y.%m.%d %H:%M")))
#+END_SRC

Increase region by semantic units. It tries to be smart about it and adapt to
the structure of the current major mode.

#+BEGIN_SRC emacs-lisp
(use-package expand-region
  :bind
  ("C-=" . er/expand-region))
#+END_SRC

Customize the noisy default towards backup files.

#+BEGIN_SRC emacs-lisp
(use-package files
  :straight nil
  :custom
  (backup-by-copying t)
  (backup-directory-alist `(("." . ,(shelldock "backups/"))))
  (delete-old-versions t)
  (version-control t))
#+END_SRC

Add visual guides towards indenting levels.

#+BEGIN_SRC emacs-lisp
(use-package highlight-indent-guides
  :hook
  (python-mode . highlight-indent-guides-mode)
  (scss-mode . highlight-indent-guides-mode)
  :custom
  (highlight-indent-guides-method 'character))
#+END_SRC

Highlight line under point.

#+BEGIN_SRC emacs-lisp
(use-package hl-line
  :straight nil
  :hook
  (dired-mode . hl-line-mode)
  (fundamental-mode . hl-line-mode)
  (prog-mode . hl-line-mode)
  (text-mode . hl-line-mode)
  :custom
  (hl-line-sticky-flag nil))
#+END_SRC

Colorize colors as text with their value.

#+BEGIN_SRC emacs-lisp
(use-package rainbow-mode
  :hook
  (help-mode . rainbow-mode)
  (prog-mode . rainbow-mode)
  :custom
  (rainbow-x-colors nil))
#+END_SRC

Enable /repeat mode/ for various commands. The mode basically allows transient
keymaps to persist after an interactive command in order to repeat it with the
single press of a button: typically the same end character of the key binding.

For instance, cycle through windows with =C-x o=, =o=... or =O=, =O=...

#+BEGIN_SRC emacs-lisp
(use-package repeat
  :straight nil
  :hook
  (after-init . repeat-mode))
#+END_SRC

Turn on =auto-fill-mode= /almost/ everywhere.

#+BEGIN_SRC emacs-lisp
(use-package simple
  :straight nil
  :hook
  (org-mode . auto-fill-mode)
  (prog-mode . auto-fill-mode)
  (text-mode . auto-fill-mode))
#+END_SRC

Tail =*Messages*= windows. This is useful when debugging naively with repeated
calls to the =message= function.

#+BEGIN_SRC emacs-lisp
(advice-add 'message :after
  (defun me/message-tail (&rest _)
    (let* ((name "*Messages*")
           (buffer (get-buffer-create name)))
      (when (not (string= name (buffer-name)))
        (dolist (window (get-buffer-window-list name nil t))
          (with-selected-window window
            (goto-char (point-max))))))))
#+END_SRC

** REST Client

Emacs can also emulate an interactive REST client.

#+BEGIN_SRC emacs-lisp
(use-package restclient
  :mode ((rx ".http" eos) . restclient-mode)
  :bind
  (:map restclient-mode-map
   ([remap restclient-http-send-current]
    . restclient-http-send-current-stay-in-window)
   ("C-n" . restclient-jump-next)
   ("C-p" . restclient-jump-prev))
  :hook
  (restclient-mode . display-line-numbers-mode))
#+END_SRC

** Terminal

Yes, Emacs emulates terminals too.

| TODO | Advice =vterm= motions to support shift            |
| TODO | Remove confirm prompt when killing =vterm= buffers |

#+BEGIN_SRC emacs-lisp
(use-package vterm
  :bind
  (:map vterm-mode-map
   ("C-c C-c" . vterm-send-C-c)))
#+END_SRC

** Version Control

Display indicators in the left fringe for Git changes. This is using the fringe
version of =git-gutter= since margins may be compromised with other features
like centered alignment and annotations. Fringes will not work under TTY.

#+BEGIN_SRC emacs-lisp
(use-package git-gutter-fringe
  :preface
  (defun me/git-gutter-enable ()
    (when-let* ((buffer (buffer-file-name))
                (backend (vc-backend buffer)))
      (require 'git-gutter)
      (require 'git-gutter-fringe)
      (git-gutter-mode 1)))
  :hook
  (after-change-major-mode . me/git-gutter-enable)
  :config
  (define-fringe-bitmap 'git-gutter-fr:added [240] nil nil '(center t))
  (define-fringe-bitmap 'git-gutter-fr:deleted [240 240 240 240] nil nil 'bottom)
  (define-fringe-bitmap 'git-gutter-fr:modified [240] nil nil '(center t))
  :custom
  (git-gutter:update-interval .1))
#+END_SRC

Major modes for Git-specific files.

#+BEGIN_SRC emacs-lisp
(use-package git-modes)
#+END_SRC

Magit provides Git facilities directly from within Emacs.

#+BEGIN_QUOTE
Magit is an interface to the version control system Git, implemented as an Emacs
package. Magit aspires to be a complete Git porcelain. While we cannot (yet)
claim that Magit wraps and improves upon each and every Git command, it is
complete enough to allow even experienced Git users to perform almost all of
their daily version control tasks directly from within Emacs. While many fine
Git clients exist, only Magit and Git itself deserve to be called porcelains.

--- Jonas Bernoulli
#+END_QUOTE

#+BEGIN_SRC emacs-lisp
(use-package magit
  :bind
  (:map magit-file-section-map
   ("<return>" . magit-diff-visit-file-other-window)
   :map magit-hunk-section-map
   ("<return>" . magit-diff-visit-file-other-window)
   :map magit-section-mode-map
   ("M-1" . nil)
   ("M-2" . nil)
   ("M-3" . nil)
   ("M-4" . nil)
   :map magit-status-mode-map
   ("M-1" . nil)
   ("M-2" . nil)
   ("M-3" . nil)
   ("M-4" . nil))
  :custom
  (epg-pinentry-mode 'loopback)
  (git-commit-fill-column 72)
  (magit-display-buffer-function
   'magit-display-buffer-same-window-except-diff-v1)
  (magit-diff-highlight-hunk-region-functions
   '(magit-diff-highlight-hunk-region-dim-outside
     magit-diff-highlight-hunk-region-using-face))
  (magit-diff-refine-hunk 'all)
  (magit-module-sections-nested nil)
  (magit-section-initial-visibility-alist
   '((modules . show) (stashes . show) (unpulled . show) (unpushed . show)))
  :config
  (magit-add-section-hook
   'magit-status-sections-hook
   'magit-insert-modules-overview
   'magit-insert-merge-log)
  (remove-hook 'magit-section-highlight-hook #'magit-diff-highlight))
#+END_SRC

Start =pinentry= in order for Emacs to be able to prompt for passphrases when
necessary.

#+BEGIN_SRC emacs-lisp
(use-package pinentry
  :hook
  (after-init . pinentry-start))
#+END_SRC

Transient is the package behind the modal maps and prefixes depicted in Magit.
It is currently used by Magit only in my configuration so it will stay in this
section for now.

#+BEGIN_SRC emacs-lisp
(use-package transient
  :custom
  (transient-default-level 5)
  (transient-mode-line-format nil)
  :init
  (setq-default
   transient-history-file (shelldock "transient/history.el")
   transient-levels-file (shelldock "transient/levels.el")
   transient-values-file (shelldock "transient/values.el")))
#+END_SRC

** Whitespaces

Highlight trailing space-like characters, eg. trailing spaces, tabs, empty
lines.

#+BEGIN_SRC emacs-lisp
(use-package whitespace
  :straight nil
  :hook
  (prog-mode . whitespace-mode)
  (text-mode . whitespace-mode)
  :custom
  (whitespace-style '(face empty indentation::space tab trailing)))
#+END_SRC

** Workspaces

Save and restore Emacs status on startup, including buffers, point and window
configurations.

#+BEGIN_SRC emacs-lisp
(use-package desktop
  :straight nil
  :defer 1
  :config
  (desktop-read)
  (desktop-save-mode)
  :custom
  (desktop-base-file-name (shelldock "desktop"))
  (desktop-base-lock-name (shelldock "desktop.lock"))
  (desktop-restore-eager 4)
  (desktop-restore-forces-onscreen 'all)
  (desktop-restore-frames t))
#+END_SRC

Workspaces within Emacs.

#+BEGIN_QUOTE
=eyebrowse= is a global minor mode for Emacs that allows you to manage your
window configurations in a simple manner, just like tiling window managers like
i3wm with their workspaces do. It displays their current state in the modeline
by default. The behaviour is modeled after =ranger=, a file manager written in
Python.

--- Vasilij Schneidermann
#+END_QUOTE

#+BEGIN_SRC emacs-lisp
(use-package eyebrowse
  :bind
  ("M-0" . eyebrowse-last-window-config)
  ("M-1" . me/eyebrowse-switch-1)
  ("M-2" . me/eyebrowse-switch-2)
  ("M-3" . me/eyebrowse-switch-3)
  ("M-4" . me/eyebrowse-switch-4)
  ("M-5" . me/eyebrowse-switch-5)
  ("M-6" . me/eyebrowse-switch-6)
  ("M-7" . me/eyebrowse-switch-7)
  ("M-8" . me/eyebrowse-switch-8)
  ("M-9" . me/eyebrowse-switch-9)
  :hook
  (after-init . eyebrowse-mode)
  :custom
  (eyebrowse-mode-line-left-delimiter "")
  (eyebrowse-mode-line-right-delimiter "")
  (eyebrowse-new-workspace t))
#+END_SRC

I've gotten used to how workspaces work in Qtile, where hitting the key for the
current workspace while in that workspace moves you to the last visited
workspace instead. The below code makes commands to /maybe-switch/ to a given
=eyebrowse= configuration in the same manner. ie. Go to the specified Nth
configuration, or to the last visited one if already visiting the Nth
configuration.

#+BEGIN_SRC emacs-lisp
(defun me/eyebrowse-switch (n)
  "Switch to configuration N or to the last visited."
  (if (eq (eyebrowse--get 'current-slot) n)
      (eyebrowse-last-window-config)
    (funcall (intern (format "eyebrowse-switch-to-window-config-%s" n)))))

(dotimes (n 9)
  (let* ((n (1+ n))
         (name (intern (format "me/eyebrowse-switch-%s" n)))
         (documentation
          (format "Switch to configuration %s or to the last visited." n)))
    (eval `(defun ,name ()
             ,documentation
             (interactive)
             (me/eyebrowse-switch ,n))
          t)))
#+END_SRC

** Windows

Olivetti lets you center your buffer for aesthetics and focus. I have it set up
to turn on automatically when windows are considered lone ie. they have no
neighbour to their left nor to their right. See the configuration for
=widowmaker=.

The configuration also conveniently silences left clicks on each of the two
margins.

#+BEGIN_SRC emacs-lisp
(use-package olivetti
  :bind
  ("<left-margin> <mouse-1>" . ignore)
  ("<right-margin> <mouse-1>" . ignore))
#+END_SRC

Set up rules for pop-ups.

#+BEGIN_SRC emacs-lisp
(use-package popper
  :bind
  ("s-<tab>" . popper-cycle)
  ("C-s-<tab>" . popper-toggle-type)
  ("s-\"" . popper-toggle-latest)
  :config
  (with-eval-after-load 'project
    (setq-default popper-group-function #'popper-group-by-project))
  :custom
  (popper-display-control nil)
  (popper-echo-lines 1)
  (popper-mode-line nil)
  (popper-reference-buffers
   `(,(rx bos "*EGLOT")
     ,(rx bos "*Messages*" eos)
     ,(rx bos "*eldoc")
     ,(rx bos "*eshell")   eshell-mode
     ,(rx bos "*terminal") vterm-mode
     help-mode
     helpful-mode))
  :hook
  (after-init . popper-mode)
  (after-init . popper-echo-mode))
#+END_SRC

Set up rules for window management.

#+BEGIN_QUOTE
=shackle= gives you the means to put an end to popped up buffers not behaving
they way you'd like them to. By setting up simple rules you can for instance
make Emacs always select help buffers for you or make everything reuse your
currently selected window.

--- Vasilij Schneidermann
#+END_QUOTE

#+BEGIN_SRC emacs-lisp
(use-package shackle
  :hook
  (after-init . shackle-mode)
  :custom
  (shackle-default-size (szadek-get 'popup-size .33))
  (shackle-inhibit-window-quit-on-same-windows t)
  (shackle-rules
   `(((help-mode helpful-mode) :align left  :select t :size 85)
     ("*Messages*"             :align below :select t)
     ("*eldoc*"                :align below :size 10)
     ("*eshell*"               :align below :popup t :select t)
     (,(rx bos "*EGLOT")       :align below :regexp t)
     (,(rx bos "*terminal")    :align below :popup t :regexp t :select t)))
  (shackle-select-reused-windows t))
#+END_SRC

Bind extra keys to manage windows and pop-ups. Also enable =olivetti-mode=
semi-automatically depending on window geometry.

#+BEGIN_SRC emacs-lisp
(use-package widowmaker
  :load-path "lisp/widowmaker"
  :straight nil
  :bind
  ("s-'" . widowmaker-terminal-dwim)
  ("s-h" . windmove-left)
  ("s-j" . windmove-down)
  ("s-k" . windmove-up)
  ("s-l" . windmove-right)
  ("s-w" . delete-window)
  ("s-W" . kill-this-buffer)
  :hook
  (after-init . winner-mode)
  (window-configuration-change . widowmaker-olivetti-maybe))
#+END_SRC
