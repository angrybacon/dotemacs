#+TITLE: DotEmacs
#+AUTHOR: Mathieu Marques
#+PROPERTY: header-args :results silent

* Bootstrap

** Better Defaults

Here are what I consider better defaults as per my own experience.

#+BEGIN_SRC emacs-lisp
(setq-default
 ad-redefinition-action 'accept         ; Silence warnings for redefinition
 auto-save-list-file-prefix nil         ; Prevent tracking for auto-saves
 create-lockfiles nil                   ; Locks are more nuisance than blessing
 cursor-in-non-selected-windows nil     ; Hide the cursor in inactive windows
 cursor-type '(hbar . 2)                ; Underline-shaped cursor
 custom-unlispify-menu-entries nil      ; Prefer kebab-case for titles
 custom-unlispify-tag-names nil         ; Prefer kebab-case for symbols
 delete-by-moving-to-trash t            ; Delete files to trash
 fill-column 80                         ; Set width for automatic line breaks
 gc-cons-threshold (* 8 1024 1024)      ; We're not using Game Boys anymore
 help-window-select t                   ; Focus new help windows when opened
 indent-tabs-mode nil                   ; Stop using tabs to indent
 inhibit-startup-screen t               ; Disable start-up screen
 initial-scratch-message ""             ; Empty the initial *scratch* buffer
 initial-major-mode #'org-mode          ; Prefer `org-mode' for *scratch*
 mouse-yank-at-point t                  ; Yank at point rather than pointer
 native-comp-async-report-warnings-errors 'silent ; Skip error buffers
 read-process-output-max (* 1024 1024)  ; Increase read size for data chunks
 recenter-positions '(5 bottom)         ; Set re-centering positions
 scroll-conservatively 101              ; Avoid recentering when scrolling far
 scroll-margin 1                        ; Add a margin when scrolling vertically
 select-enable-clipboard t              ; Merge system's and Emacs' clipboard
 sentence-end-double-space nil          ; Use a single space after dots
 show-help-function nil                 ; Disable help text everywhere
 tab-always-indent 'complete            ; Indent first then try completions
 tab-width 4                            ; Smaller width for tab characters
 uniquify-buffer-name-style 'forward    ; Uniquify buffer names
 use-short-answers t                    ; Replace yes/no prompts with y/n
 window-combination-resize t            ; Resize windows proportionally
 x-stretch-cursor t)                    ; Stretch cursor to the glyph width
(blink-cursor-mode 0)                   ; Prefer a still cursor
(delete-selection-mode 1)               ; Replace region when inserting text
(global-subword-mode 1)                 ; Iterate through CamelCase words
(mouse-avoidance-mode 'exile)           ; Avoid collision of mouse with point
(put 'downcase-region 'disabled nil)    ; Enable `downcase-region'
(put 'scroll-left 'disabled nil)        ; Enable `scroll-left'
(put 'upcase-region 'disabled nil)      ; Enable `upcase-region'
(set-default-coding-systems 'utf-8)     ; Default to utf-8 encoding
#+END_SRC

Change a few indenting behaviors.

#+BEGIN_SRC emacs-lisp
(put 'add-function 'lisp-indent-function 2)
(put 'advice-add 'lisp-indent-function 2)
(put 'plist-put 'lisp-indent-function 2)
#+END_SRC

Unbind the =suspend-frame= command.

#+BEGIN_SRC emacs-lisp
(global-unset-key (kbd "C-x C-z"))
#+END_SRC

** Fullscreen

Enable fullscreen. Given there are differences in meaning for /fullscreen/
between window managers, the following tree aims to provide a pain-free
experience with regard to fullscreen in most setups.

In the case of macOS, fullscreen means Emacs will occupy a dedicated workspace
so we want to maximize it instead. Works best with titlebar-less frames.

Ideally, this should stay near the top of the file so that Emacs appear
fullscreen immediately.

#+BEGIN_SRC emacs-lisp
(pcase window-system
  ('w32 (set-frame-parameter nil 'fullscreen 'fullboth))
  (_ (set-frame-parameter nil 'fullscreen 'maximized)))
#+END_SRC

** Packages

This configuration relies on =straight= and prefers latest Git heads for its
packages over the default behavior from the built-in =package.el= which pulls
releases from (M)ELPA.

For customizing and loading the packages, =use-package= incentivizes clearly
defined, consistent and more efficient configurations for all packages used in
this document.

#+BEGIN_SRC emacs-lisp
(setq-default
 straight-use-package-by-default t)     ; Allow `use-package' interface
#+END_SRC

Bootstrap =straight=.

#+BEGIN_SRC emacs-lisp
(let* ((bootstrap-file "straight/repos/straight.el/bootstrap.el")
       (bootstrap-path (expand-file-name bootstrap-file user-emacs-directory))
       (bootstrap-version 5)
       (install.el "https://raw.githubusercontent.com/raxod502/straight.el/develop/install.el"))
  (unless (file-exists-p bootstrap-path)
    (with-current-buffer
        (url-retrieve-synchronously install.el 'silent 'inhibit-cookies)
      (goto-char (point-max))
      (eval-print-last-sexp)))
  (load bootstrap-path nil 'nomessage))
#+END_SRC

Install =use-package= and defer all packages by default.

#+BEGIN_SRC emacs-lisp
(straight-use-package 'use-package)
(setq-default use-package-always-defer t)
#+END_SRC

** Core Function and Commands

In an effort to clean up the file as much as possible and in order to promote
reusability, some features will be written and moved under a common core
package.

#+BEGIN_SRC emacs-lisp
(use-package manticore
  :demand t
  :load-path "lisp/manticore"
  :straight nil)
#+END_SRC

** Cache

Use =.cache/= to contain local data. This is to avoid littering in the Emacs
directory with an ever-growing number of packages used on a daily basis.

#+BEGIN_SRC emacs-lisp
(use-package shelldock
  :load-path "lisp/shelldock"
  :straight nil
  :commands (shelldock))
#+END_SRC

Garbage-collect on focus-out, Emacs /should/ feel snappier overall.

#+BEGIN_SRC emacs-lisp
(add-function :after after-focus-change-function
  (defun me/garbage-collect-maybe ()
    (unless (frame-focus-state)
      (garbage-collect))))
#+END_SRC

I chose to lay out my configurations and customizations in this very Org
document for better visibility and maintainability through time and various
upgrades. Albeit useful, the =customize-*= routines go against that strategy by
writing directly at the end of the =user-init-file= or into a dedicated file
when set accordingly.

To fight the littering I've decided to completely disable this feature and
redirect the writing to =/dev/null=.

#+BEGIN_SRC emacs-lisp
(setq-default custom-file null-device)
#+END_SRC

** Load Secrets

Small framework to read secrets out of a machine-local file. Mostly to keep
sensible values out of version control, this is also used to have
machine-specific settings.

#+BEGIN_SRC emacs-lisp
(use-package szadek
  :load-path "lisp/szadek"
  :straight nil
  :commands (szadek-get)
  :custom
  (szadek-file (shelldock "szadek.eld"))
  (szadek-fix-missing t))
#+END_SRC

* Theme

** Morophon

#+BEGIN_SRC emacs-lisp
(use-package morophon
  :load-path "lisp/morophon"
  :straight nil
  :commands (morophon-cycle morophon-disable-themes)
  :custom
  (morophon-known-themes '(zenmelt modus-operandi)))
#+END_SRC

** Customize Fringes

Customize line-continuation indicator bitmaps.

#+BEGIN_SRC emacs-lisp
(define-fringe-bitmap 'left-curly-arrow [16 48 112 240 240 112 48 16])
(define-fringe-bitmap 'right-curly-arrow [8 12 14 15 15 14 12 8])
#+END_SRC

Mute their colors as well.

#+BEGIN_SRC emacs-lisp
(set-fringe-bitmap-face 'left-curly-arrow 'shadow)
(set-fringe-bitmap-face 'right-curly-arrow 'shadow)
#+END_SRC

** Customize Typography

#+BEGIN_SRC emacs-lisp
(defun me/typography-reset ()
  "Set the base settings for typography faces."
  (interactive)
  (let ((font-fixed (szadek-get 'font-fixed "monospace"))
        (font-size (szadek-get 'font-size 120))
        (font-variable (szadek-get 'font-variable "sans-serif")))
    (set-face-attribute 'default nil :font font-fixed :height font-size)
    (set-face-attribute 'fixed-pitch nil :font font-fixed :height font-size)
    (set-face-attribute 'mode-line nil :height font-size :inherit 'default)
    (set-face-attribute 'mode-line-inactive nil :inherit 'mode-line)
    (set-face-attribute 'variable-pitch nil :font font-variable)))
(me/typography-reset)
#+END_SRC

Automatically re-apply the configuration whenever the values change. See
[[#load-secrets][Load Secrets]].

#+BEGIN_SRC emacs-lisp
(add-hook 'szadek-on-save-hook #'me/typography-reset)
#+END_SRC

** Themes

#+BEGIN_SRC emacs-lisp
(use-package modus-themes
  :straight nil
  :custom
  (modus-themes-diffs 'fg-only)
  (modus-themes-mode-line '(accented borderless))
  (modus-themes-no-mixed-fonts t)
  (modus-themes-operandi-color-overrides
   '((bg-main . "#FAFAFA")
     (fg-main . "#101010")
     (fg-window-divider-inner . "#FAFAFA")))
  (modus-themes-org-blocks 'tinted-background)
  :hook
  (morophon-after-load-theme . me/modus-themes-override)
  :preface
  (defun me/modus-themes-override ()
    "Override some of the 'modus-operandi theme.
This function should be called everytime the theme is loaded."
    (when (member 'modus-operandi custom-enabled-themes)
      (custom-theme-set-faces
       'modus-operandi
       '(doom-modeline-bar ((t (:inherit mode-line))))
       '(doom-modeline-bar-inactive ((t (:inherit mode-line-inactive))))))))
#+END_SRC

All praise the alien fruit salad theme!
[[https://kippura.org/zenburnpage/][Zenburn]].

I have been using this /easy-on-the-eyes/ pastel theme for a very long time.
After having added one too many customization to it, I went ahead and made my
own fork: Zenmelt.

It doesn't support the many packages that have made it to your own
configurations on purpose, the idea -- albeit selfish -- is to have one place
where I can freely customize colors following my moods without having to
maintain a 2K lines-long file of unnecessary face properties.

In addition to the already popular implementation from
[[https://github.com/bbatsov/zenburn-emacs][Bozhidar Batsov]], this fork also
adds a /reset/ on save when visiting the theme file.

#+BEGIN_SRC emacs-lisp
(use-package zenmelt-theme
  :demand
  :load-path "lisp/zenmelt"
  :straight nil
  :config
  (put 'after-save-hook 'safe-local-variable
       (lambda (value) (equal value '(zenmelt--reset t))))
  (load-theme 'zenmelt :noconfirm))
#+END_SRC

* Languages

** CSV

#+BEGIN_SRC emacs-lisp
(use-package csv-mode
  :bind
  (:map csv-mode-map
   ("<backtab>" . csv-backward-field)
   ("<tab>" . csv-forward-field))
  :hook
  (csv-mode . csv-align-mode))
#+END_SRC

** HTML

HTML mode is defined in =sgml-mode.el=.

#+BEGIN_SRC emacs-lisp
(use-package sgml-mode
  :straight nil
  :hook
  (html-mode . (lambda () (setq me/pretty-print-function #'sgml-pretty-print)))
  (html-mode . sgml-electric-tag-pair-mode)
  (html-mode . sgml-name-8bit-mode)
  :custom
  (sgml-basic-offset 2))
#+END_SRC

** JavaScript

Since Emacs 29, =js-ts-mode=, =typescript-ts-mode= and =tsx-ts-mode= are the
built-in major modes to edit JavaScript buffers relying on
[[#tree-sitter][Tree-sitter]] to power up the syntax highlighting.

#+BEGIN_SRC emacs-lisp
(use-package typescript-ts-mode
  :straight nil
  :hook
  (tsx-ts-mode . sgml-electric-tag-pair-mode))
#+END_SRC

** Lisp

#+BEGIN_SRC emacs-lisp
(use-package emacs-lisp-mode
  :straight nil
  :bind
  (:map emacs-lisp-mode-map
   ("C-c C-c" . manticore-eval-region-dwim)
   ("C-x C-S-e" . eval-print-last-sexp)
   :map lisp-interaction-mode-map
   ("C-c C-c" . manticore-eval-region-dwim)
   ("C-x C-S-e" . eval-print-last-sexp))
  :custom
  (emacs-lisp-docstring-fill-column nil)
  :hook
  (emacs-lisp-mode . flymake-mode)
  (emacs-lisp-mode . outline-minor-mode))
#+END_SRC

#+BEGIN_SRC emacs-lisp
(use-package ielm
  :straight nil
  :hook
  (ielm-mode . (manticore-scroll-margin-disable)))
#+END_SRC

#+BEGIN_SRC emacs-lisp
(use-package lisp-mode
  :straight nil
  :mode ((rx ".eld" eos) . lisp-data-mode))
#+END_SRC

** Markdown

#+BEGIN_SRC emacs-lisp
(use-package markdown-mode
  :mode (rx (or "INSTALL" "CONTRIBUTORS" "LICENSE" "README" ".mdx") eos)
  :bind
  (:map markdown-mode-map
   ("M-n" . nil)
   ("M-p" . nil))
  :custom
  (markdown-asymmetric-header t)
  (markdown-fontify-code-blocks-natively t)
  (markdown-list-indent-width 2)
  (markdown-split-window-direction 'right)
  :config
  (unbind-key "M-<down>" markdown-mode-map)
  (unbind-key "M-<up>" markdown-mode-map)
  (add-to-list 'markdown-code-lang-modes '("tsx" . tsx-ts-mode)))
#+END_SRC

** Org

This very file is organized with =org-mode=. Like Markdown, but with
superpowers.

| TODO | Check out =org-capture= |

#+BEGIN_QUOTE
Org mode is for keeping notes, maintaining TODO lists, planning projects, and
authoring documents with a fast and effective plain-text system.

--- Carsten Dominik
#+END_QUOTE

#+BEGIN_SRC emacs-lisp
(use-package org
  :straight (:type built-in)
  :bind
  (:map org-mode-map
   ("C-<return>" . nil)
   ("C-<tab>" . me/org-cycle-parent)
   ("C-S-<down>" . nil)                 ; Free paragraph command
   ("C-S-<up>" . nil))                  ; Free paragraph command
  :custom
  (org-confirm-babel-evaluate nil)
  (org-cycle-separator-lines 0)
  (org-descriptive-links nil)
  (org-edit-src-content-indentation 0)
  (org-edit-src-persistent-message nil)
  (org-fontify-done-headline t)
  (org-fontify-quote-and-verse-blocks t)
  (org-fontify-whole-heading-line t)
  (org-return-follows-link t)
  (org-src-window-setup 'current-window)
  (org-startup-truncated nil)
  (org-support-shift-select 'always)
  :config
  (add-to-list 'org-src-lang-modes (cons "ts" 'typescript-ts))
  (add-to-list 'org-src-lang-modes (cons "tsx" 'tsx-ts))
  (add-to-list
   'safe-local-variable-values '(after-save-hook . (org-babel-tangle t)))
  (require 'ob-shell)
  (org-babel-do-load-languages
   'org-babel-load-languages '((python . t) (shell . t)))
  (modify-syntax-entry ?' "'" org-mode-syntax-table)
  (advice-add 'org-src--construct-edit-buffer-name :override #'me/org-src-buffer)
  (with-eval-after-load 'evil
    (evil-define-key* 'motion org-mode-map
      (kbd "<tab>") #'org-cycle
      (kbd "C-j") #'me/org-show-next-heading-tidily
      (kbd "C-k") #'me/org-show-previous-heading-tidily))
  :hook
  (org-mode . buffer-face-mode))
#+END_SRC

#+BEGIN_SRC emacs-lisp
(defun me/org-src-buffer (name &rest _)
  "Simple buffer name."
  (format "*%s*" name))

(defun me/org-cycle-parent (argument)
  "Go to the nearest parent heading and execute `org-cycle'."
  (interactive "p")
  (if (org-at-heading-p)
      (outline-up-heading argument)
    (org-previous-visible-heading argument))
  (org-cycle))

(defun me/org-show-next-heading-tidily ()
  "Show next entry, keeping other entries closed."
  (interactive)
  (if (save-excursion (end-of-line) (outline-invisible-p))
      (progn (org-show-entry) (outline-show-children))
    (outline-next-heading)
    (unless (and (bolp) (org-at-heading-p))
      (org-up-heading-safe)
      (outline-hide-subtree)
      (user-error "[Dotemacs] Boundary reached"))
    (org-overview)
    (org-reveal t)
    (org-show-entry)
    (outline-show-children)))

(defun me/org-show-previous-heading-tidily ()
  "Show previous entry, keeping other entries closed."
  (interactive)
  (let ((pos (point)))
    (outline-previous-heading)
    (unless (and (< (point) pos) (bolp) (org-at-heading-p))
      (goto-char pos)
      (outline-hide-subtree)
      (user-error "[Dotemacs] Boundary reached"))
    (org-overview)
    (org-reveal t)
    (org-show-entry)
    (outline-show-children)))
#+END_SRC

Install major modes otherwise unused to edit configuration blocks from Org.

#+BEGIN_SRC emacs-lisp
(use-package haskell-mode)
(use-package vimrc-mode)
#+END_SRC

* Features

** Completion

*** Consult

Provide various commands to list and /consult/ existing collections.

#+BEGIN_SRC emacs-lisp
(use-package consult
  :bind
  ([remap goto-line] . consult-goto-line)
  ([remap isearch-forward] . consult-line)
  ([remap switch-to-buffer] . consult-buffer)
  ("C-h M" . consult-minor-mode-menu)
  :custom
  (consult-line-start-from-top t)
  (consult-project-root-function #'me/project-root)
  (xref-show-definitions-function #'consult-xref)
  (xref-show-xrefs-function #'consult-xref)
  :init
  (with-eval-after-load 'evil
    (evil-global-set-key 'motion "gm" #'consult-mark)
    (evil-global-set-key 'motion "gM" #'consult-imenu)
    (evil-global-set-key 'motion "go" #'consult-outline)))
#+END_SRC

*** Corfu

#+BEGIN_SRC emacs-lisp
(use-package corfu
  :hook
  (after-init . global-corfu-mode)
  :custom
  (corfu-auto t)
  (corfu-auto-delay .5))
#+END_SRC

#+BEGIN_SRC emacs-lisp
(use-package corfu-popupinfo
  :load-path "straight/build/corfu/extensions"
  :straight nil
  :custom
  (corfu-popupinfo-delay '(1.0 . t))
  :hook
  (global-corfu-mode . corfu-popupinfo-mode))
#+END_SRC

*** Marginalia

#+BEGIN_SRC emacs-lisp
(use-package marginalia
  :hook
  (after-init . marginalia-mode))
#+END_SRC

*** Orderless

Allow completion based on space-separated tokens, out of order.

#+BEGIN_SRC emacs-lisp
(use-package orderless
  :custom
  (completion-styles '(orderless))
  (orderless-component-separator 'orderless-escapable-split-on-space))
#+END_SRC

*** Vertico

Prettify the completion minibuffer featuring keyboard-driven vertical navigation
with live-reload.

#+BEGIN_SRC emacs-lisp
(use-package vertico
  :custom
  (vertico-count-format '("%-5s " . "%2$s"))
  (vertico-resize nil)
  :hook
  (after-init . vertico-mode))
#+END_SRC

** Comments

Comment things using Evil operators.

#+BEGIN_SRC emacs-lisp
(use-package evil-commentary
  :hook
  (evil-mode . evil-commentary-mode))
#+END_SRC

Customize the way default comments should be handled.

#+BEGIN_SRC emacs-lisp
(use-package newcomment
  :straight nil
  :bind
  ("M-<return>" . comment-indent-new-line)
  :hook
  (prog-mode . (lambda () (setq-local comment-auto-fill-only-comments t)))
  :custom
  (comment-multi-line t))
#+END_SRC

** Context Actions

*** Embark

#+BEGIN_SRC emacs-lisp
(use-package embark
  :bind
  ("C-;" . embark-act)
  ([remap describe-bindings] . embark-bindings)
  :config
  (require 'embark-consult)
  :custom
  (embark-indicators
   '(embark-highlight-indicator
     embark-isearch-highlight-indicator
     embark-minimal-indicator))
  (prefix-help-command #'embark-prefix-help-command))
#+END_SRC

#+BEGIN_SRC emacs-lisp
(use-package embark-consult)
#+END_SRC

*** Selected

Enable new custom binds when region is active. I've also added a few helpers to
use with =selected=.

| TODO | Bind these to the =evil-visual= map |

#+BEGIN_SRC emacs-lisp
(use-package selected
  :bind*
  (:map selected-keymap
   ("C-c c"       . capitalize-region)
   ("C-c k"       . barrinalo-kebab)
   ("C-q"         . selected-off)
   ("C-s n"       . barrinalo-sort-numbers)
   ("C-s r"       . barrinalo-reverse)
   ("C-s s"       . sort-lines)
   ("C-s w"       . barrinalo-sort-words)
   ("C-<tab>"     . me/pretty-print)
   ("M-<left>"    . barrinalo-indent-leftward)
   ("M-<right>"   . barrinalo-indent-rightward)
   ("M-S-<left>"  . barrinalo-indent-leftward-tab)
   ("M-S-<right>" . barrinalo-indent-rightward-tab))
  :hook
  (after-init . selected-global-mode)
  :config
  (require 'barrinalo)
  :custom
  (selected-minor-mode-override t))
#+END_SRC

#+BEGIN_SRC emacs-lisp
(defvar-local me/pretty-print-function nil)

(defun me/pretty-print (beg end)
  (interactive "r")
  (if me/pretty-print-function
      (progn (funcall me/pretty-print-function beg end)
             (setq deactivate-mark t))
    (user-error "[Dotemacs] `me/pretty-print-function' is not set")))
#+END_SRC

** Diff

Ediff is a visual interface to Unix =diff=.

#+BEGIN_SRC emacs-lisp
(use-package ediff-wind
  :straight nil
  :custom
  (ediff-split-window-function #'split-window-horizontally)
  (ediff-window-setup-function #'ediff-setup-windows-plain))
#+END_SRC

** Dired

Configure the /dir/ectory /ed/itor. Amongst many other things, Emacs also ships
with a file explorer.

#+BEGIN_SRC emacs-lisp
(use-package dired
  :straight nil
  :custom
  (dired-auto-revert-buffer t)
  (dired-dwim-target t)
  (dired-hide-details-hide-symlink-targets nil)
  (dired-listing-switches "-Aghov --group-directories-first")
  (dired-kill-when-opening-new-dired-buffer t)
  (dired-recursive-copies 'always)
  :hook
  (dired-mode . auto-revert-mode)
  (dired-mode . dired-hide-details-mode))
#+END_SRC

Dire serves as a repository for all my Dired commands and helpers. Some of them
will be bound directly to =dired-mode-map=, others will remain unbound
interactive commands.

#+BEGIN_SRC emacs-lisp
(use-package dire
  :load-path "lisp/dire"
  :straight nil
  :bind
  (:map dired-mode-map
   ("C-<return>" . dire-open-externally)))
#+END_SRC

** Documentation

When [[https://debbugs.gnu.org/cgi/bugreport.cgi?bug=47109][this patch]] is
sorted out, we'll be able to use a new format function to have pieces of
documentation joined with a horizontal rule. eg.

#+BEGIN_SRC emacs-lisp :tangle no
(setq-default
 eldoc-documentation-format-function #'eldoc-documentation-format-concat-hr)
#+END_SRC

#+BEGIN_SRC emacs-lisp
(use-package eldoc
  :straight nil
  :custom
  (eldoc-documentation-strategy 'eldoc-documentation-compose-eagerly)
  (eldoc-echo-area-prefer-doc-buffer t)
  (eldoc-idle-delay .1))
#+END_SRC

** Evil

Evil emulates and manages the infamous Vim states and motions ported to Emacs.

| TODO | Make transient maps for buffer motions and =winner= commands |

#+BEGIN_SRC emacs-lisp
(use-package evil
  :bind
  (:map evil-inner-text-objects-map
   ("g" . me/evil-buffer)
   :map evil-outer-text-objects-map
   ("g" . me/evil-buffer)
   :map evil-insert-state-map
   ("C-a" . nil)                        ; Free Readline key
   ("C-e" . nil)                        ; Free Readline key
   ("C-w" . nil)                        ; Free kill command
   ("S-<left>" . nil)                   ; Free motion command
   ("S-<right>" . nil)                  ; Free motion command
   :map evil-motion-state-map
   ("RET" . nil)                        ; Free return command
   ("gb" . switch-to-buffer)
   ("gB" . project-switch-to-buffer)
   ("gC" . describe-face)
   ("gr" . manticore-revert-buffer-immediately)
   ("gs" . avy-goto-char-timer)
   ("gS" . avy-goto-char)
   ("C-e" . nil)                        ; Free Readline key
   ("C-]" . nil)                        ; Free abort edit command
   ("C-S-d" . evil-scroll-up)
   :map evil-normal-state-map
   ("q" . me/evil-record-macro-or-quit)
   ("gd" . dired-jump)
   ("gD" . project-dired)
   ("gf" . me/project-find-file)
   ("gp" . project-switch-project)
   ("M-." . nil)                        ; Free xref command
   :map evil-visual-state-map
   ("f" . fill-region)
   :map evil-window-map
   ("u" . winner-undo)
   ("C-r" . winner-redo))
  :custom
  (evil-echo-state nil)
  (evil-emacs-state-cursor (default-value 'cursor-type))
  (evil-undo-system 'undo-redo)
  (evil-visual-state-cursor 'hollow)
  (evil-want-keybinding nil)
  :config
  (evil-select-search-module 'evil-search-module 'evil-search)
  (add-to-list 'evil-emacs-state-modes 'exwm-mode)
  (add-to-list 'evil-emacs-state-modes 'dired-mode)
  (add-to-list 'evil-emacs-state-modes 'process-menu-mode)
  (add-to-list 'evil-emacs-state-modes 'profiler-report-mode)
  (add-to-list 'evil-emacs-state-modes 'vterm-mode)
  (add-to-list 'evil-insert-state-modes 'with-editor-mode)
  (add-to-list 'evil-motion-state-modes 'helpful-mode)
  (evil-define-text-object me/evil-buffer (_count &optional _begin _end type)
    "Text object to represent the whole buffer."
    (evil-range (point-min) (point-max) type))
  (advice-add 'evil-indent :around #'manticore-save-excursion)
  :hook
  (after-init . evil-mode)
  (after-save . evil-normal-state))
#+END_SRC

#+BEGIN_SRC emacs-lisp
(defun me/evil-record-macro-or-quit ()
  "Quit the current window or record a macro when the buffer is writeable."
  (interactive)
  (if buffer-read-only
      (quit-window)
    (call-interactively #'evil-record-macro)))
#+END_SRC

Provide =gl= and =gL= align operators, ported from =vim-lion=.

#+BEGIN_SRC emacs-lisp
(use-package evil-lion
  :hook
  (evil-mode . evil-lion-mode))
#+END_SRC

Emulate =vim-surround=. Take actions with surrounding pairs.

#+BEGIN_SRC emacs-lisp
(use-package evil-surround
  :hook
  (after-init . global-evil-surround-mode))
#+END_SRC

Activate volatile keymaps for split sizing.

| TODO | Use =repeat-mode= instead |

#+BEGIN_SRC emacs-lisp
(defun me/evil-window-resize-continue (&optional _count)
  "Activate a sparse keymap for evil window resizing routines in order to
support repeated key strokes."
  (set-transient-map
   (let ((map (make-sparse-keymap)))
     (define-key map (kbd "-") #'evil-window-decrease-height)
     (define-key map (kbd "+") #'evil-window-increase-height)
     (define-key map (kbd "<") #'evil-window-decrease-width)
     (define-key map (kbd ">") #'evil-window-increase-width)
     map)))

(advice-add 'evil-window-decrease-height :after #'me/evil-window-resize-continue)
(advice-add 'evil-window-increase-height :after #'me/evil-window-resize-continue)
(advice-add 'evil-window-decrease-width :after #'me/evil-window-resize-continue)
(advice-add 'evil-window-increase-width :after #'me/evil-window-resize-continue)
#+END_SRC

** Expand

HippieExpand manages expansions a la [[http://emmet.io/][Emmet]]. So I've
gathered all features that look anywhere close to this behavior for it to handle
them under the same bind, that is =<C-return>=. It's basically an expand DWIM.

#+BEGIN_SRC emacs-lisp
(use-package emmet-mode
  :bind
  (:map emmet-mode-keymap
   ("C-<return>" . nil))
  :hook
  (css-base-mode . emmet-mode)
  (html-mode . emmet-mode)
  (tsx-ts-mode . emmet-mode)
  :custom
  (emmet-insert-flash-time .1)
  (emmet-jsx-className-braces? t)
  (emmet-move-cursor-between-quote t)
  :preface
  (defun me/emmet-try-expand (args)
    "Try `emmet-expand-line' if `emmet-mode' is active. Else, does nothing."
    (interactive "P")
    (when emmet-mode (emmet-expand-line args))))
#+END_SRC

#+BEGIN_SRC emacs-lisp
(use-package hippie-exp
  :straight nil
  :bind
  ("C-<return>" . hippie-expand)
  :custom
  (hippie-expand-try-functions-list
   '(yas-hippie-try-expand me/emmet-try-expand))
  (hippie-expand-verbose nil))
#+END_SRC

#+BEGIN_SRC emacs-lisp
(use-package yasnippet
  :bind
  (:map yas-minor-mode-map
   ("TAB" . nil)
   ([tab] . nil))
  :hook
  (prog-mode . yas-minor-mode)
  (text-mode . yas-minor-mode)
  :custom
  (yas-verbosity 2)
  :config
  (yas-reload-all))
#+END_SRC

** Help

Bind useful commands in help buffers.

#+BEGIN_SRC emacs-lisp
(use-package help-mode
  :straight nil
  :bind
  ("C-h K" . describe-keymap)
  (:map help-mode-map
   ("<" . help-go-back)
   (">" . help-go-forward))
  :config
  (with-eval-after-load 'evil
    (evil-define-key* 'motion help-mode-map
      (kbd "<tab>") #'forward-button)))
#+END_SRC

Provide better detailed help buffers.

#+BEGIN_SRC emacs-lisp
(use-package helpful
  :bind
  ([remap describe-command] . helpful-command)
  ([remap describe-function] . helpful-callable)
  ([remap describe-key] . helpful-key)
  ([remap describe-symbol] . helpful-symbol)
  ([remap describe-variable] . helpful-variable)
  ("C-h F" . helpful-function)
  :config
  (with-eval-after-load 'evil
    (evil-define-key* 'motion helpful-mode-map
      (kbd "gr") #'helpful-update
      (kbd "<tab>") #'forward-button))
  :custom
  (helpful-max-buffers 2))
#+END_SRC

** Hydra

Hydra allows me to group binds together. It also shows a list of all implemented
commands in the echo area.

#+BEGIN_QUOTE
Once you summon the Hydra through the prefixed binding (the body + any one
head), all heads can be called in succession with only a short extension.

The Hydra is vanquished once Hercules, any binding that isn't the Hydra's head,
arrives. Note that Hercules, besides vanquishing the Hydra, will still serve his
original purpose, calling his proper command. This makes the Hydra very
seamless, it's like a minor mode that disables itself auto-magically.

--- Oleh Krehel
#+END_QUOTE

*** Hydra: Bootstrap

Augments and bootstrap helpers for =hydra=. Work in progress.

#+BEGIN_SRC emacs-lisp
(use-package hercules
  :demand
  :load-path "lisp/hercules"
  :straight nil)
#+END_SRC

#+BEGIN_SRC emacs-lisp
(use-package hydra
  :bind
  ("C-c d" . hydra-dates/body)
  ("C-c g" . hydra-git/body)
  ("C-c i" . hydra-interface/body)
  ("C-c p" . hydra-project/body)
  ("C-c s" . hydra-system/body)
  ("C-c v" . hydra-visit/body)
  :custom
  (hydra-default-hint nil))
#+END_SRC

*** Hydra: Dates

Group date-related commands.

#+BEGIN_SRC emacs-lisp
(defhydra hydra-dates (:color teal)
  (concat (hercules-heading "Insert" "Insert with Time") "
 _d_ short           _D_ short           ^^
 _i_ iso             _I_ iso             ^^
 _l_ long            _L_ long            ^^")
  ("q" nil)
  ("d" barrinalo-date-short)
  ("D" barrinalo-date-short-with-time)
  ("i" barrinalo-date-iso)
  ("I" barrinalo-date-iso-with-time)
  ("l" barrinalo-date-long)
  ("L" barrinalo-date-long-with-time))
#+END_SRC

*** Hydra: Git

Group =git= commands.

#+BEGIN_SRC emacs-lisp
(defhydra hydra-git (:color teal :idle 1.0)
  (concat (hercules-heading "Do" "Gutter") "
 _b_ blame           _p_ previous        ^^
 _c_ clone           _n_ next            ^^
 _g_ status          _r_ revert          ^^
 _m_ smerge...       _s_ stage           ^^")
  ("q" nil)
  ("b" magit-blame)
  ("c" magit-clone)
  ("g" magit-status)
  ("m" (progn (require 'smerge-mode) (hydra-git--smerge/body)))
  ("n" git-gutter:next-hunk :color red)
  ("p" git-gutter:previous-hunk :color red)
  ("r" git-gutter:revert-hunk)
  ("s" git-gutter:stage-hunk :color red))
#+END_SRC

Group =smerge= commands under the Git hydra.

#+BEGIN_SRC emacs-lisp
(defhydra hydra-git--smerge (:color pink
                             :pre (if (not smerge-mode) (smerge-mode 1))
                             :post (smerge-auto-leave))
  (concat (hercules-heading "Move" "Keep" "Diff") "
 _g_ first           _RET_ current       _<_ upper / base
 _G_ last            _a_ all             _=_ upper / lower
 _j_ next            _b_ base            _>_ base / lower
 _k_ previous        _l_ lower           _E_ ediff
 ^^                  _u_ upper           _H_ highlight")
  ("q" nil :color blue)
  ("j" smerge-next)
  ("k" smerge-prev)
  ("<" smerge-diff-base-upper :color blue)
  ("=" smerge-diff-upper-lower :color blue)
  (">" smerge-diff-base-lower :color blue)
  ("RET" smerge-keep-current)
  ("a" smerge-keep-all)
  ("b" smerge-keep-base)
  ("E" smerge-ediff :color blue)
  ("g" (progn (goto-char (point-min)) (smerge-next)))
  ("G" (progn (goto-char (point-max)) (smerge-prev)))
  ("H" smerge-refine)
  ("l" smerge-keep-lower)
  ("u" smerge-keep-upper))
#+END_SRC

*** Hydra: Interface

Group interface-related commands.

| TODO | Check out =defhydradio=                               |
| TODO | Improve =hercules-heading= to accept a list of fields |

#+BEGIN_SRC emacs-lisp
(defhydra hydra-interface (:color pink :pre (require 'morophon))
  (concat (hercules-heading "Do" "Zoom" "Toggles") "
 _m_ maximize frame  _-_ out             _a_ / _A_ alpha: %s`morophon--alpha
 _M_ cycle displays  _=_ in              _n_ line numbers: %s`display-line-numbers
 _t_ cycle theme     _0_ reset           _o_ olivetti: %s`widowmaker-olivetti-automatic
 ^^                  ^^                  _O_ olivetti width: %s`olivetti-body-width")
  ("q" nil)
  ("-" default-text-scale-decrease)
  ("=" default-text-scale-increase)
  ("0" default-text-scale-reset :color blue)
  ("a" morophon-alpha-less)
  ("A" morophon-alpha-more)
  ("m" toggle-frame-maximized)
  ("M" widowmaker-placement-cycle)
  ("n" ruric-toggle-line-numbers)
  ("o" widowmaker-olivetti-automatic-toggle :color blue)
  ("O" widowmaker-olivetti-body-reset :color blue)
  ("<" widowmaker-olivetti-body-less)
  (">" widowmaker-olivetti-body-more)
  ("t" morophon-cycle :color blue)
  ("T" morophon-cycle))
#+END_SRC

*** Hydra: Project

Group project-related commands.

#+BEGIN_SRC emacs-lisp
(defhydra hydra-project (:color teal :idle 1.0)
  (concat (hercules-heading "Do" "Find" "Search") "
 _K_ kill buffers    _d_ directory       _r_ replace
 _o_ edit todo       _D_ root            _s_ ripgrep
 _t_ forget project  _f_ file            ^^
 _T_ prune projects  _p_ project         ^^")
  ("q" nil)
  ("d" project-find-dir)
  ("D" project-dired)
  ("f" project-find-file)
  ("K" project-kill-buffers)
  ("o" me/project-todo)
  ("p" project-switch-project)
  ("r" project-query-replace-regexp)
  ("s" me/project-search)
  ("t" project-forget-project)
  ("T" project-forget-zombie-projects))
#+END_SRC

*** Hydra: System

Group system-related commands.

#+BEGIN_SRC emacs-lisp
(defhydra hydra-system (:color teal)
  (concat (hercules-heading "Do" "Packages" "Toggles") "
 _d_ clear compiled  _p_ install         _g_ debug: %-3s`debug-on-error
 _D_ clear desktop   _P_ prune           ^^
 _l_ processes       _u_ update          ^^
 _Q_ clear and kill  _U_ update all      ^^")
  ("q" nil)
  ("d" manticore-delete-compiled)
  ("D" desktop-remove)
  ("g" (setq debug-on-error (not debug-on-error)))
  ("l" list-processes)
  ("p" straight-use-package)
  ("P" (progn (straight-remove-unused-repos) (straight-prune-build)))
  ("Q" (let ((desktop-save nil))
         (manticore-delete-compiled)
         (desktop-remove)
         (save-buffers-kill-terminal)))
  ("u" straight-pull-package)
  ("U" straight-pull-all))
#+END_SRC

*** Hydra: Visit

Group shortcuts for often-accessed configuration files.

#+BEGIN_SRC emacs-lisp
(defhydra hydra-visit (:color teal :idle 1.0)
  (concat (hercules-heading "Visit") "
 _._ secrets         _e_ emacs           _s_ zsh
 _c_ picom           _l_ linux           _t_ kitty
 _d_ qtile           _m_ macos           _v_ vim
 ^^                  _n_ dunst           ^^")
  ("q" nil)
  ("." (find-file "~/.config/emacs/.cache/szadek.eld"))
  ("c" (find-file "~/Workspace/dot/config/picom.org"))
  ("d" (find-file "~/Workspace/dot/config/qtile.org"))
  ("e" (find-file (concat user-emacs-directory "dotemacs.org")))
  ("l" (find-file "~/Workspace/dot/LINUX.org"))
  ("m" (find-file "~/Workspace/dot/MACOS.org"))
  ("n" (find-file "~/Workspace/dot/config/dunst.org"))
  ("s" (find-file "~/Workspace/dot/config/zsh.org"))
  ("t" (find-file "~/Workspace/dot/config/kitty.org"))
  ("v" (find-file "~/Workspace/dot/config/vim.org")))
#+END_SRC

** Intellisense

*** Code References

Find code references throughout a codebase.

#+BEGIN_SRC emacs-lisp
(use-package xref
  :straight nil
  :bind
  ([remap xref-find-apropos] . xref-find-definitions)
  ([remap xref-find-definitions] . xref-find-definitions-other-window)
  :config
  (with-eval-after-load 'evil
    (evil-define-key* 'motion xref--xref-buffer-mode-map
      (kbd "<backtab") #'xref-prev-group
      (kbd "<return") #'xref-goto-xref
      (kbd "<tab>") #'xref-next-group)))
#+END_SRC

*** Language Server Protocol

Yup, Emacs supports LSP.

#+BEGIN_SRC emacs-lisp
(use-package eglot
  :straight nil
  :config
  (add-to-list 'eglot-stay-out-of 'eldoc-documentation-strategy)
  (put 'eglot-error 'flymake-overlay-control nil)
  (put 'eglot-warning 'flymake-overlay-control nil)
  (advice-add 'eglot--apply-workspace-edit :after #'me/project-save)
  (advice-add 'project-kill-buffers :before #'me/eglot-shutdown-project)
  :custom
  (eglot-autoshutdown t)
  (eglot-events-buffer-size 0)
  :hook
  (eglot-managed-mode . me/flymake-eslint-enable-maybe)
  (typescript-ts-base-mode . eglot-ensure)
  :init
  (put 'eglot-server-programs 'safe-local-variable 'listp)
  :preface
  (defun me/eglot-shutdown-project ()
    "Kill the LSP server for the current project if it exists."
    (when-let ((server (eglot-current-server)))
      (ignore-errors (eglot-shutdown server)))))
#+END_SRC

*** Linters

#+BEGIN_SRC emacs-lisp
(use-package flymake
  :straight nil
  :custom
  (flymake-fringe-indicator-position nil))
#+END_SRC

#+BEGIN_SRC emacs-lisp
(use-package flymake-eslint
  :preface
  (defun me/flymake-eslint-enable-maybe ()
    "Enable `flymake-eslint' based on the project configuration.
Search for the project ESLint configuration to determine whether the buffer
should be checked."
    (when-let* ((root (locate-dominating-file (buffer-file-name) "package.json"))
                (rc (locate-file ".eslintrc" (list root) '(".js" ".json"))))
      (make-local-variable 'exec-path)
      (push (file-name-concat root "node_modules" ".bin") exec-path)
      (flymake-eslint-enable))))
#+END_SRC

Run /Prettier/ against the whole buffer on save. See the
[[#directory-local-variables][Directory-Local Variables]] section for automatic
enabling of the minor mode.

#+BEGIN_SRC emacs-lisp
(use-package prettier
  :init
  (add-to-list 'safe-local-eval-forms '(prettier-mode)))
#+END_SRC

*** Tree-Sitter

Use [[https://tree-sitter.github.io/tree-sitter/][Tree-Sitter]] to handle more
complex syntax trees where the default alternatives lack the highlighting power.

Emacs 29 can be built with tree-sitter bindings built-in by default and the
below configuration assumes as much. Language modules can be built from
[[https://github.com/casouri/tree-sitter-module]].

#+BEGIN_SRC emacs-lisp
(use-package treesit
  :straight nil
  :init
  (push '(css-mode . css-ts-mode) major-mode-remap-alist)
  (push '(javascript-mode . js-ts-mode) major-mode-remap-alist)
  (push '(js-mode . js-ts-mode) major-mode-remap-alist)
  (push '(js-json-mode . json-ts-mode) major-mode-remap-alist)
  (push '(python-mode . python-ts-mode) major-mode-remap-alist))
#+END_SRC

#+BEGIN_SRC emacs-lisp
(use-package tree-sitter-module
  :straight (:host github :repo "casouri/tree-sitter-module" :type git
             :files ("dist/*.dylib" "dist/*.so")
             :pre-build ("./batch.sh"))
  :after treesit
  :init
  (add-to-list 'treesit-extra-load-path
               (straight--build-dir "tree-sitter-module")))
#+END_SRC

** Line Numbers

Display relative line numbers in most editing modes.

#+BEGIN_SRC emacs-lisp
(add-hook 'conf-mode-hook #'display-line-numbers-mode)
(add-hook 'prog-mode-hook #'display-line-numbers-mode)
(add-hook 'text-mode-hook #'display-line-numbers-mode)
(setq-default
 display-line-numbers-grow-only t
 display-line-numbers-type 'relative
 display-line-numbers-width 3)
#+END_SRC

Allow file-local overrides for the width that numbers should take.

#+BEGIN_SRC emacs-lisp
(put 'display-line-numbers-width 'safe-local-variable 'integerp)
#+END_SRC

** Mode-Line

Prettify the mode-line with customizable and conditional segments.

| TODO | Make a =arecord -vvv -f dat /dev/null= segment |

#+BEGIN_SRC emacs-lisp
(use-package doom-modeline
  :demand t
  :custom
  (doom-modeline-bar-width (szadek-get 'mode-line-width 8))
  (doom-modeline-buffer-file-name-style 'truncate-with-project)
  (doom-modeline-height (szadek-get 'mode-line-height 36))
  (doom-modeline-enable-word-count t)
  (doom-modeline-major-mode-icon nil)
  (doom-modeline-percent-position nil)
  (doom-modeline-vcs-max-length 28)
  :config
  (doom-modeline-def-segment me/buffer
    "The buffer description and major mode icon."
    (concat doom-modeline-spc (doom-modeline--buffer-name) doom-modeline-spc))
  (doom-modeline-def-segment me/position
    "The buffer position."
    (let* ((active (doom-modeline--active))
           (face (if active 'mode-line 'mode-line-inactive)))
      (propertize (concat doom-modeline-spc
                          (format-mode-line "%l:%c")
                          doom-modeline-spc)
                  'face face)))
  (doom-modeline-def-segment me/buffer-simple
    "The buffer name but simpler."
    (let* ((active (doom-modeline--active))
           (face (cond ((and buffer-file-name (buffer-modified-p))
                        'doom-modeline-buffer-modified)
                       (active 'doom-modeline-buffer-file)
                       (t 'mode-line-inactive))))
      (concat doom-modeline-spc
              (propertize "%b" 'face face)
              doom-modeline-spc)))
  (doom-modeline-def-segment me/default-directory
    "The buffer directory."
    (let* ((active (doom-modeline--active))
           (face (if active 'doom-modeline-buffer-path 'mode-line-inactive)))
      (concat doom-modeline-spc
              (propertize (abbreviate-file-name default-directory) 'face face)
              doom-modeline-spc)))
  (doom-modeline-def-segment me/evil
    "The current Evil state."
    (doom-modeline--evil))
  (doom-modeline-def-segment me/flymake
    "The error status with color codes and icons."
    (when (bound-and-true-p flymake-mode)
      (let ((active (doom-modeline--active))
            (icon doom-modeline--flymake-icon)
            (text doom-modeline--flymake-text))
        (concat
         (when icon
           (concat doom-modeline-spc
                   (if active
                       icon
                     (doom-modeline-propertize-icon icon 'mode-line-inactive))))
         (when text
           (concat (if icon doom-modeline-vspc doom-modeline-spc)
                   (if active
                       text
                     (propertize text 'face 'mode-line-inactive))))
         (when (or icon text)
           doom-modeline-spc)))))
  (doom-modeline-def-segment me/info
    "The topic and nodes in Info buffers."
    (let ((active (doom-modeline--active)))
      (concat
       (propertize " (" 'face (if active 'mode-line 'mode-line-inactive))
       (propertize (if (stringp Info-current-file)
                       (replace-regexp-in-string
                        "%" "%%" (file-name-sans-extension
                                  (file-name-nondirectory Info-current-file)))
                     (format "*%S*" Info-current-file))
                   'face (if active 'doom-modeline-info 'mode-line-inactive))
       (propertize ") " 'face (if active 'mode-line 'mode-line-inactive))
       (when Info-current-node
         (propertize (concat
                      (replace-regexp-in-string "%" "%%" Info-current-node)
                      doom-modeline-spc)
                     'face (if active
                               'doom-modeline-buffer-path
                             'mode-line-inactive))))))
  (doom-modeline-def-segment me/major
    "The current major mode, including environment information."
    (let* ((active (doom-modeline--active))
           (face (if active
                     'doom-modeline-buffer-major-mode
                   'mode-line-inactive)))
      (concat doom-modeline-spc
              (propertize (format-mode-line mode-name) 'face face)
              doom-modeline-spc)))
  (doom-modeline-def-segment me/vcs
    "The version control system information."
    (when-let ((branch doom-modeline--vcs-text))
      (let ((active (doom-modeline--active))
            (text (concat ":" branch)))
        (concat doom-modeline-spc
                (if active text (propertize text 'face 'mode-line-inactive))
                doom-modeline-spc))))
  (doom-modeline-mode 1)
  (doom-modeline-def-modeline 'info
    '(bar me/evil me/buffer me/info me/position selection-info)
    '(irc-buffers matches process debug me/major workspace-name))
  (doom-modeline-def-modeline 'main
    '(bar me/evil me/buffer remote-host me/position me/flymake selection-info)
    '(irc-buffers matches process me/vcs debug me/major workspace-name))
  (doom-modeline-def-modeline 'message
    '(bar me/evil me/buffer-simple me/position selection-info)
    '(irc-buffers matches process me/major workspace-name))
  (doom-modeline-def-modeline 'org-src
    '(bar me/evil me/buffer-simple me/position me/flymake selection-info)
    '(irc-buffers matches process debug me/major workspace-name))
  (doom-modeline-def-modeline 'project
    '(bar me/evil me/default-directory)
    '(irc-buffers matches process debug me/major workspace-name))
  (doom-modeline-def-modeline 'special
    '(bar me/evil me/buffer me/position selection-info)
    '(irc-buffers matches process debug me/major workspace-name))
  (doom-modeline-def-modeline 'vcs
    '(bar me/evil me/buffer remote-host me/position selection-info)
    '(irc-buffers matches process debug me/major workspace-name)))
#+END_SRC

** Multiple Cursors

Add support for multiple cursors within Evil.

#+BEGIN_SRC emacs-lisp
(use-package evil-multiedit
  :after evil
  :bind
  (:map evil-normal-state-map
   ("M-d". evil-multiedit-match-symbol-and-next)
   ("M-D". evil-multiedit-match-symbol-and-prev)
   ("C-M-d". evil-multiedit-match-all)
   :map evil-visual-state-map
   ("M-d". evil-multiedit-match-and-next)
   ("M-D". evil-multiedit-match-and-prev)
   ("C-M-d". evil-multiedit-match-all)))
#+END_SRC

** Navigation

#+BEGIN_QUOTE
=avy= is a GNU Emacs package for jumping to visible text using a char-based
decision tree. See also =ace-jump-mode= and =vim-easymotion= -- =avy= uses the
same idea.

--- Oleh Krehel
#+END_QUOTE

#+BEGIN_SRC emacs-lisp
(use-package avy
  :custom
  (avy-background t)
  (avy-style 'at-full)
  (avy-timeout-seconds .3))
#+END_SRC

#+BEGIN_QUOTE
Evil-snipe emulates =vim-seek= and/or =vim-sneak= in =evil-mode=.

--- Henrik Lissner
#+END_QUOTE

#+BEGIN_SRC emacs-lisp
(use-package evil-snipe
  :hook
  (evil-mode . evil-snipe-mode)
  (evil-mode . evil-snipe-override-mode)
  :custom
  (evil-snipe-char-fold t)
  (evil-snipe-repeat-scope 'visible)
  (evil-snipe-smart-case t))
#+END_SRC

I disagree with some of Emacs' opinion with regards to paragraphs amongst other
things. =hanna= is a collection of replacements for the aforementioned defaults.

#+BEGIN_SRC emacs-lisp
(use-package hanna
  :load-path "lisp/hanna"
  :straight nil
  :bind
  ([remap move-beginning-of-line] . hanna-beginning-of-line)
  ([remap backward-paragraph] . hanna-paragraph-backward)
  ([remap forward-paragraph] . hanna-paragraph-forward)
  ("<wheel-right>" . hanna-scroll-horizontal+2)
  ("<wheel-left>" . hanna-scroll-horizontal-2)
  ("<double-wheel-right>" . hanna-scroll-horizontal+4)
  ("<double-wheel-left>" . hanna-scroll-horizontal-4)
  ("<triple-wheel-right>" . hanna-scroll-horizontal+8)
  ("<triple-wheel-left>" . hanna-scroll-horizontal-8))
#+END_SRC

Isearch stands for /incremental search/. This means that search results are
updated and highlighted while you are typing your query, incrementally.

#+BEGIN_SRC emacs-lisp
(use-package isearch
  :straight nil
  :bind
  (("C-S-r" . isearch-backward-regexp)
   ("C-S-s" . isearch-forward-regexp))
  :custom
  (isearch-allow-scroll t)
  (lazy-highlight-buffer t)
  (lazy-highlight-cleanup nil)
  (lazy-highlight-initial-delay 0))
#+END_SRC

Customize the scrolling behavior using the mouse wheel.

#+BEGIN_SRC emacs-lisp
(use-package mwheel
  :straight nil
  :custom
  (mouse-wheel-progressive-speed nil)
  (mouse-wheel-scroll-amount '(2 ((control) . 8))))
#+END_SRC

Pulse strategic locations in the current buffer for readability and focus
purposes.

#+BEGIN_SRC emacs-lisp
(use-package pulsar
  :defer 1
  :hook
  (after-init . pulsar-global-mode))
#+END_SRC

** OS-Specific

Initialize environment variables.

#+BEGIN_QUOTE
Ever find that a command works in your shell, but not in Emacs?

This happens a lot on OS X, where an Emacs instance started from the GUI
inherits a default set of environment variables.

This library works solves this problem by copying important environment
variables from the user's shell: it works by asking your shell to print out the
variables of interest, then copying them into the Emacs environment.

--- Steve Purcell
#+END_QUOTE

| TODO | Figure out how to feed nvm path from a non-interactive shell |

#+BEGIN_SRC emacs-lisp
(use-package exec-path-from-shell
  :if (eq window-system 'ns)
  :hook
  (after-init . exec-path-from-shell-initialize))
#+END_SRC

Augment Emacs experience for MacOS users.

#+BEGIN_SRC emacs-lisp
(when (eq system-type 'darwin)
  (setq-default
   ns-alternate-modifier 'super         ; Map Super to the Alt key
   ns-command-modifier 'meta            ; Map Meta to the Cmd key
   ns-pop-up-frames nil                 ; Always re-use the same frame
   ns-use-mwheel-momentum nil))         ; Disable smooth scroll
#+END_SRC

Provide a way to invoke =bash= on Windows. This requires /Developer Mode/ to be
enabled in the first place.

#+BEGIN_SRC emacs-lisp
(when (eq system-type 'windows-nt)
  (defun me/bash ()
    "Run Bash executable under System32."
    (interactive)
    (let ((explicit-shell-file-name "C:/Windows/System32/bash.exe"))
      (shell))))
#+END_SRC

** Pair-Programming

Adjust font size for all windows at once.

#+BEGIN_QUOTE
This package provides commands for increasing or decreasing the default font
size in all GUI Emacs frames -- it is like an Emacs-wide version of
=text-scale-mode=.

--- Steve Purcell
#+END_QUOTE

#+BEGIN_SRC emacs-lisp
(use-package default-text-scale)
#+END_SRC

When broadcasting your Emacs session over video online it can be useful to tone
down the Emacs'ness. Summon the two-headed ogre Ruric with =M-x ruric-mode= and
start your pair-programming session.

#+BEGIN_SRC emacs-lisp
(use-package ruric
  :load-path "lisp/ruric"
  :straight nil
  :commands
  (ruric-global-mode
   ruric-mode
   ruric-toggle-line-numbers
   ruric-toggle-line-numbers-absolute))
#+END_SRC

** Parentheses

Highlight parenthese-like delimiters in a rainbow fashion. It eases the reading
when dealing with mismatched parentheses.

#+BEGIN_SRC emacs-lisp
(use-package rainbow-delimiters
  :hook
  (prog-mode . rainbow-delimiters-mode))
#+END_SRC

I am still looking for the perfect parenthesis management setup as of today...
No package seem to please my person.

#+BEGIN_SRC emacs-lisp
(use-package smartparens
  :bind
  ("M-<backspace>" . sp-unwrap-sexp)
  ("M-<left>" . sp-forward-barf-sexp)
  ("M-<right>" . sp-forward-slurp-sexp)
  ("M-S-<left>" . sp-backward-slurp-sexp)
  ("M-S-<right>" . sp-backward-barf-sexp)
  :hook
  (after-init . smartparens-global-mode)
  (wdired-mode . smartparens-mode)
  :custom
  (sp-highlight-pair-overlay nil)
  (sp-highlight-wrap-overlay nil)
  (sp-highlight-wrap-tag-overlay nil)
  :config
  (show-paren-mode 0)
  (require 'smartparens-config))
#+END_SRC

** Paste

#+BEGIN_QUOTE
This mode allows to paste whole buffers or parts of buffers to pastebin-like
services. It supports more than one service and will failover if one service
fails.

--- Elis Hirwing
#+END_QUOTE

| TODO | Handle Org blocks https://github.com/etu/webpaste.el/issues/13 |

#+BEGIN_SRC emacs-lisp
(use-package webpaste
  :config
  (with-eval-after-load 'evil
    (evil-global-set-key 'visual "p" #'webpaste-paste-region))
  :custom
  (webpaste-provider-priority '("paste.mozilla.org" "dpaste.org")))
#+END_SRC

** Presentation

#+BEGIN_SRC emacs-lisp
(use-package org-present
  :hook
  (org-present-mode . me/org-present-start)
  (org-present-mode-quit . me/org-present-end)
  :preface
  (defvar-local me/org-present-face-remap-cookies nil
    "Keep the face remappings around to revert them.")
  (defun me/org-present-end ()
    "Configurations to run when `org-present-mode' ends."
    (setq
     header-line-format nil
     org-hide-emphasis-markers nil)
    (mapc #'face-remap-remove-relative me/org-present-face-remap-cookies)
    (setq face-remap-remove-relative nil)
    (display-line-numbers-mode 1)
    (hl-line-mode 1)
    (org-remove-inline-images)
    (evil-initialize-state)
    (widowmaker-olivetti-body-reset))
  (defun me/org-present-start ()
    "Configurations to run when `org-present-mode' starts."
    (beginning-of-buffer)
    (setq
     header-line-format " "
     org-hide-emphasis-markers t)
    (push (face-remap-add-relative 'default 'variable-pitch)
          me/org-present-face-remap-cookies)
    (push (face-remap-add-relative 'header-line '(:height 4.0))
          me/org-present-face-remap-cookies)
    (push (face-remap-add-relative 'org-block 'fixed-pitch)
          me/org-present-face-remap-cookies)
    (push (face-remap-add-relative 'org-block 'hl-line)
          me/org-present-face-remap-cookies)
    (push (face-remap-add-relative 'org-block-begin-line 'fixed-pitch)
          me/org-present-face-remap-cookies)
    (push (face-remap-add-relative 'org-block-begin-line 'hl-line)
          me/org-present-face-remap-cookies)
    (display-line-numbers-mode 0)
    (hl-line-mode 0)
    (org-display-inline-images)
    (org-present-big)
    (evil-emacs-state)
    (widowmaker-olivetti-body-reset 50)))
#+END_SRC

** Project

*** Project.el

Provide project-wide commands and utilities.

#+BEGIN_SRC emacs-lisp
(use-package project
  :straight nil
  :custom
  (project-list-file (shelldock "projects.eld"))
  (project-switch-commands
   '((project-dired "Root" ?D)
     (project-find-file "File" ?f)
     (magit-project-status "Git" ?g)
     (me/project-todo "Todo" ?o)
     (me/project-search "Search" ?s)
     (widowmaker-terminal-dwim "Terminal" ?t))))
#+END_SRC

#+BEGIN_SRC emacs-lisp
(defun me/project-find-file ()
  "Find a file under the current project.
If not in a project, fallback to `find-file-at-point' instead."
  (interactive)
  (if (project-current)
      (call-interactively #'project-find-file)
    (call-interactively #'find-file-at-point)))

(defun me/project-name (&optional project)
  "Return the name for PROJECT.
If PROJECT is not specified, assume current project root."
  (when-let (root (or project (me/project-root)))
    (file-name-nondirectory
     (directory-file-name
      (file-name-directory root)))))

(defun me/project-save (&rest _)
  "Save file-visiting buffers under the current project root."
  (interactive)
  (save-some-buffers t #'save-some-buffers-root))

(defun me/project-search ()
  "Run ripgrep against project root.
If ripgrep is not installed, use grep instead."
  (interactive)
  (let ((root (me/project-root)))
    (if (executable-find "rg")
        (consult-ripgrep root)
      (message "[Dotemacs] Could not find 'rg', using 'grep' instead")
      (consult-grep root))))

(defun me/project-root ()
  "Return the current project root."
  (when-let (project (project-current))
    (project-root project)))

(defun me/project-todo ()
  "Visit the todo file for the current project."
  (interactive)
  (if-let (root (me/project-root))
      (find-file (expand-file-name "TODO.org" root))
    (user-error "[Dotemacs] Not in a project")))
#+END_SRC

*** Directory-Local Variables

In order to customize specifics directories recursively and without polluting
the Emacs Lisp configuration, one can provide directory-local variables through
a strategically positioned =.dir-locals.el= file. An alternative way is to
resort to /directory classes/ for reusability across different projects.

First define a standard setup for /Prettier/ projects. That is, projects where
/Prettier/ should be enabled for a number of major modes by default.

#+BEGIN_SRC emacs-lisp
(dir-locals-set-class-variables 'prettier
 '((css-base-mode . ((eval . (prettier-mode))))
   (js-base-mode . ((eval . (prettier-mode))))
   (json-ts-mode . ((eval . (prettier-mode))))
   (typescript-ts-base-mode . ((eval . (prettier-mode))))))
#+END_SRC

Assign paths to specific classes according to specifications found in secrets.

#+BEGIN_SRC emacs-lisp
(defun me/dir-locals-set-directories ()
  "Apply directory-local class variables to the appropriate project paths."
  (interactive)
  (mapc (lambda (it) (dir-locals-set-directory-class it 'prettier))
        (szadek-get 'projects-prettier)))
(me/dir-locals-set-directories)
#+END_SRC

Automatically re-apply the configuration whenever the values change. See
[[#load-secrets][Load Secrets]].

#+BEGIN_SRC emacs-lisp
(add-hook 'szadek-on-save-hook #'me/dir-locals-set-directories)
#+END_SRC

Below is an example of secrets setting 2 /Prettier/ projects.

#+BEGIN_SRC lisp-data :tangle no
((projects-prettier
  . ("~/path/to/react/project/one/"
     "~/path/to/react/project/two/")))
#+END_SRC

** Quality of Life

Turn on =auto-fill-mode= /almost/ everywhere.

#+BEGIN_SRC emacs-lisp
(add-hook 'prog-mode-hook #'auto-fill-mode)
(add-hook 'text-mode-hook #'auto-fill-mode)
#+END_SRC

A collection of text-changing and transpose functions.

#+BEGIN_SRC emacs-lisp
(use-package barrinalo
  :load-path "lisp/barrinalo"
  :straight nil
  :bind
  ("M-p" . barrinalo-swap-up)
  ("M-n" . barrinalo-swap-down)
  ("M-P" . barrinalo-duplicate-backward)
  ("M-N" . barrinalo-duplicate-forward))
#+END_SRC

Add syntax highlighting support for configuration files.

#+BEGIN_SRC emacs-lisp
(use-package conf-mode
  :straight nil
  :mode (rx (or ".list"
                "CODEOWNERS"
                (and ".env" (* (and "." (+ word))))
                (and "." (+ word) "rc"))
            eos))
#+END_SRC

Increase region by semantic units. It tries to be smart about it and adapt to
the structure of the current major mode.

#+BEGIN_SRC emacs-lisp
(use-package expand-region
  :bind
  ("C-=" . er/expand-region))
#+END_SRC

Customize the noisy default towards backup files.

#+BEGIN_SRC emacs-lisp
(use-package files
  :straight nil
  :custom
  (backup-by-copying t)
  (backup-directory-alist `(("." . ,(shelldock "backups/"))))
  (delete-old-versions t)
  (version-control t))
#+END_SRC

Add visual guides towards indenting levels.

#+BEGIN_SRC emacs-lisp
(use-package highlight-indent-guides
  :hook
  (css-base-mode . highlight-indent-guides-mode)
  (python-mode . highlight-indent-guides-mode)
  (yaml-ts-mode . highlight-indent-guides-mode)
  :custom
  (highlight-indent-guides-method 'character))
#+END_SRC

Highlight line under point.

#+BEGIN_SRC emacs-lisp
(use-package hl-line
  :straight nil
  :hook
  (dired-mode . hl-line-mode)
  (fundamental-mode . hl-line-mode)
  (prog-mode . hl-line-mode)
  (text-mode . hl-line-mode)
  :custom
  (hl-line-sticky-flag nil))
#+END_SRC

Colorize colors as text with their value.

#+BEGIN_SRC emacs-lisp
(use-package rainbow-mode
  :hook
  (css-base-mode . rainbow-mode)
  (help-mode . rainbow-mode)
  :init
  (add-to-list 'safe-local-eval-forms
               '(when (require 'rainbow-mode nil :noerror) (rainbow-mode 1)))
  :custom
  (rainbow-x-colors nil))
#+END_SRC

Enable /repeat mode/ for various commands. The mode basically allows transient
keymaps to persist after an interactive command in order to repeat it with the
single press of a button: typically the same end character of the key binding.

For instance, cycle through windows with =C-x o=, =o=... or =O=, =O=...

#+BEGIN_SRC emacs-lisp
(use-package repeat
  :straight nil
  :hook
  (after-init . repeat-mode))
#+END_SRC

Tail =*Messages*= windows. This is useful when debugging naively with repeated
calls to the =message= function.

#+BEGIN_SRC emacs-lisp
(advice-add 'message :after
  (defun me/message-tail (&rest _)
    "Automatically scroll the message buffer to the bottom on new messages"
    (let* ((name "*Messages*")
           (buffer (get-buffer-create name)))
      (when (not (string= name (buffer-name)))
        (dolist (window (get-buffer-window-list name nil :all-frames))
          (with-selected-window window
            (goto-char (point-max))))))))
#+END_SRC

Allow editable grep results.

| TODO | Automatically enter insert state |

#+BEGIN_SRC emacs-lisp
(use-package wgrep
  :config
  (with-eval-after-load 'evil
    (advice-add 'wgrep-abort-changes :after #'evil-initialize-state))
  :custom
  (wgrep-auto-save-buffer t))
#+END_SRC

** REST Client

Emacs can also emulate an interactive REST client.

#+BEGIN_SRC emacs-lisp
(use-package restclient
  :mode ((rx ".http" eos) . restclient-mode)
  :bind
  (:map restclient-mode-map
   ([remap restclient-http-send-current]
    . restclient-http-send-current-stay-in-window)
   ("C-n" . restclient-jump-next)
   ("C-p" . restclient-jump-prev))
  :hook
  (restclient-mode . display-line-numbers-mode))
#+END_SRC

** Terminal

Yes, Emacs emulates a terminal too.

| TODO | Advice =vterm= motions to support shift |

#+BEGIN_SRC emacs-lisp
(use-package vterm
  :bind
  (:map vterm-mode-map
   ([remap kill-this-buffer] . widowmaker-kill-process-buffer)))
#+END_SRC

** Version Control

Display Git changes indicators in the left fringe. Fringes are not available
under TTY.

#+BEGIN_SRC emacs-lisp
(use-package diff-hl
  :config
  (define-fringe-bitmap 'me/diff-hl-insert [240] nil nil '(center t))
  (define-fringe-bitmap 'me/diff-hl-change [240] nil nil '(center t))
  (define-fringe-bitmap 'me/diff-hl-delete (make-vector 6 240) nil nil 'top)
  ;; (with-eval-after-load 'magit
  ;;   (add-hook 'magit-pre-refresh-hook #'diff-hl-magit-pre-refresh)
  ;;   (add-hook 'magit-post-refresh-hook #'diff-hl-magit-post-refresh))
  :custom
  (diff-hl-fringe-bmp-function #'me/diff-hl-fringe-bitmap)
  (diff-hl-show-staged-changes nil)
  :hook
  ((prog-mode text-mode) . diff-hl-mode)
  (diff-hl-mode . diff-hl-flydiff-mode)
  (dired-mode . diff-hl-dired-mode)
  :preface
  (defun me/diff-hl-fringe-bitmap (type _position)
    "Return the name of the bitmap to use for a given change TYPE."
    (intern (format "me/diff-hl-%s" type))))
#+END_SRC

Major modes for Git-specific files.

#+BEGIN_SRC emacs-lisp
(use-package git-modes)
#+END_SRC

Magit provides Git facilities directly from within Emacs.

#+BEGIN_QUOTE
Magit is an interface to the version control system Git, implemented as an Emacs
package. Magit aspires to be a complete Git porcelain. While we cannot (yet)
claim that Magit wraps and improves upon each and every Git command, it is
complete enough to allow even experienced Git users to perform almost all of
their daily version control tasks directly from within Emacs. While many fine
Git clients exist, only Magit and Git itself deserve to be called porcelains.

--- Jonas Bernoulli
#+END_QUOTE

#+BEGIN_SRC emacs-lisp
(use-package magit
  :bind
  (:map magit-file-section-map
   ("<return>" . magit-diff-visit-file-other-window)
   :map magit-hunk-section-map
   ("<return>" . magit-diff-visit-file-other-window)
   :map magit-section-mode-map
   ("M-1" . nil)
   ("M-2" . nil)
   ("M-3" . nil)
   ("M-4" . nil)
   :map magit-status-mode-map
   ("M-1" . nil)
   ("M-2" . nil)
   ("M-3" . nil)
   ("M-4" . nil))
  :custom
  (epg-pinentry-mode 'loopback)
  (magit-display-buffer-function
   'magit-display-buffer-same-window-except-diff-v1)
  (magit-diff-highlight-hunk-region-functions
   '(magit-diff-highlight-hunk-region-dim-outside
     magit-diff-highlight-hunk-region-using-face))
  (magit-diff-refine-hunk 'all)
  (magit-module-sections-nested nil)
  (magit-section-initial-visibility-alist
   '((modules . show) (stashes . show) (unpulled . show) (unpushed . show)))
  :config
  (magit-add-section-hook
   'magit-status-sections-hook
   'magit-insert-modules-overview
   'magit-insert-merge-log)
  (remove-hook 'magit-section-highlight-hook #'magit-diff-highlight))
#+END_SRC

Start =pinentry= in order for Emacs to be able to prompt for passphrases when
necessary.

#+BEGIN_SRC emacs-lisp
(use-package pinentry
  :hook
  (after-init . pinentry-start))
#+END_SRC

Transient is the package behind the modal maps and prefixes depicted in Magit.
It is currently used by Magit only in my configuration so it will stay in this
section for now.

#+BEGIN_SRC emacs-lisp
(use-package transient
  :init
  (setq-default
   transient-history-file (shelldock "transient/history.el")
   transient-levels-file (shelldock "transient/levels.el")
   transient-values-file (shelldock "transient/values.el"))
  :custom
  (transient-default-level 5)
  (transient-show-popup nil))
#+END_SRC

** Whitespaces

Highlight trailing space-like characters, eg. trailing spaces, tabs, empty
lines.

#+BEGIN_SRC emacs-lisp
(use-package whitespace
  :straight nil
  :hook
  (prog-mode . whitespace-mode)
  (text-mode . whitespace-mode)
  :custom
  (whitespace-style '(face empty indentation::space tab trailing)))
#+END_SRC

** Workspaces

Save and restore Emacs status on startup, including buffers, point and window
configurations.

#+BEGIN_SRC emacs-lisp
(use-package desktop
  :straight nil
  :defer 1
  :config
  (desktop-read)
  (desktop-save-mode)
  :custom
  (desktop-base-file-name (shelldock "desktop"))
  (desktop-base-lock-name (shelldock "desktop.lock"))
  (desktop-restore-eager 4)
  (desktop-restore-forces-onscreen 'all)
  (desktop-restore-frames t))
#+END_SRC

Workspaces within Emacs.

#+BEGIN_QUOTE
=eyebrowse= is a global minor mode for Emacs that allows you to manage your
window configurations in a simple manner, just like tiling window managers like
i3wm with their workspaces do. It displays their current state in the modeline
by default. The behaviour is modeled after =ranger=, a file manager written in
Python.

--- Vasilij Schneidermann
#+END_QUOTE

#+BEGIN_SRC emacs-lisp
(use-package eyebrowse
  :bind
  ("M-1" . me/eyebrowse-switch-1)
  ("M-2" . me/eyebrowse-switch-2)
  ("M-3" . me/eyebrowse-switch-3)
  ("M-4" . me/eyebrowse-switch-4)
  ("M-5" . me/eyebrowse-switch-5)
  ("M-6" . me/eyebrowse-switch-6)
  ("M-7" . me/eyebrowse-switch-7)
  ("M-8" . me/eyebrowse-switch-8)
  ("M-9" . me/eyebrowse-switch-9)
  :hook
  (after-init . eyebrowse-mode)
  :custom
  (eyebrowse-mode-line-left-delimiter "")
  (eyebrowse-mode-line-right-delimiter "")
  (eyebrowse-new-workspace t))
#+END_SRC

I've gotten used to how workspaces work in Qtile, where hitting the key for the
current workspace while in that workspace moves you to the last visited
workspace instead. The below code makes commands to /maybe-switch/ to a given
=eyebrowse= configuration in the same manner. ie. Go to the specified Nth
configuration, or to the last visited one if already visiting the Nth
configuration.

#+BEGIN_SRC emacs-lisp
(defun me/eyebrowse-switch (n)
  "Switch to configuration N or to the last visited."
  (if (eq (eyebrowse--get 'current-slot) n)
      (eyebrowse-last-window-config)
    (funcall (intern (format "eyebrowse-switch-to-window-config-%s" n)))))

(dotimes (n 9)
  (let* ((n (1+ n))
         (name (intern (format "me/eyebrowse-switch-%s" n)))
         (documentation
          (format "Switch to configuration %s or to the last visited." n)))
    (eval `(defun ,name ()
             ,documentation
             (interactive)
             (me/eyebrowse-switch ,n))
          t)))
#+END_SRC

** Windows

Olivetti lets you center your buffer for aesthetics and focus. I have it set up
to turn on automatically when windows are considered lone ie. they have no
neighbour to their left nor to their right. See the configuration for
=widowmaker=.

The configuration also conveniently silences left clicks on each of the two
margins.

#+BEGIN_SRC emacs-lisp
(use-package olivetti
  :bind
  ("<left-margin> <mouse-1>" . ignore)
  ("<right-margin> <mouse-1>" . ignore))
#+END_SRC

Set up rules for pop-ups.

#+BEGIN_SRC emacs-lisp
(use-package popper
  :bind
  ("s-\"" . popper-toggle-latest)
  ("s-<tab>" . popper-cycle)
  (:map popper-mode-map
   ("C-s-\"" . popper-toggle-type))
  :config
  (with-eval-after-load 'project
    (setq-default popper-group-function #'popper-group-by-project))
  :custom
  (popper-display-control nil)
  (popper-echo-lines 1)
  (popper-mode-line nil)
  (popper-reference-buffers
   `(,(rx bos "*EGLOT")
     ,(rx bos "*Messages*" eos)
     ,(rx bos "*Process List*" eos)
     ,(rx bos "*eldoc")
     ,(rx bos "*eshell")
     ,(rx bos "*terminal")
     eshell-mode
     help-mode
     helpful-mode
     magit-process-mode
     vterm-mode))
  :hook
  (after-init . popper-mode)
  (after-init . popper-echo-mode))
#+END_SRC

Set up rules for window management.

#+BEGIN_QUOTE
=shackle= gives you the means to put an end to popped up buffers not behaving
they way you'd like them to. By setting up simple rules you can for instance
make Emacs always select help buffers for you or make everything reuse your
currently selected window.

--- Vasilij Schneidermann
#+END_QUOTE

#+BEGIN_SRC emacs-lisp
(use-package shackle
  :custom
  (shackle-default-size (szadek-get 'popup-size .33))
  (shackle-inhibit-window-quit-on-same-windows t)
  (shackle-rules
   `((compilation-mode               :align below :popup t)
     (magit-process-mode             :align below :popup t)
     ("*Messages*"                   :align below :popup t)
     (,(rx bos "*EGLOT")             :align below :popup t :regexp t)
     (embark-collect-mode            :align below :popup t :select t)
     (grep-mode                      :align below :popup t :select t)
     ("*Process List*"               :align below :popup t :select t)
     ("*dired-check-process output*" :align below :popup t :select t)
     ("*eldoc*"                      :align below :popup t :select t)
     ("*eshell*"                     :align below :popup t :select t)
     (,(rx bos "*terminal")          :align below :popup t :select t :regexp t)
     (help-mode                      :align left  :popup t :select t :size 82)
     (helpful-mode                   :align left  :popup t :select t :size 82)))
  (shackle-select-reused-windows t)
  :hook
  (after-init . shackle-mode))
#+END_SRC

Bind extra keys to manage windows and pop-ups. Also enable =olivetti-mode=
semi-automatically depending on window geometry.

#+BEGIN_SRC emacs-lisp
(use-package widowmaker
  :load-path "lisp/widowmaker"
  :straight nil
  :bind
  ("s-'" . widowmaker-terminal-dwim)
  ("s-h" . windmove-left)
  ("s-j" . windmove-down)
  ("s-k" . windmove-up)
  ("s-l" . windmove-right)
  ("s-w" . delete-window)
  ("s-W" . kill-this-buffer)
  :hook
  (after-init . winner-mode)
  (window-configuration-change . widowmaker-olivetti-maybe))
#+END_SRC
